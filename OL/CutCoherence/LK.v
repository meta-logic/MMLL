(** * System LK for classical logic encoded as an LL theory

This file encodes the inference rules of the system LK. Since the
rules used are cut-coherent, the cut-elimination theorem applies for
this system.
 *)


Require Import MMLL.OL.CutCoherence.OLTactics.
Require Import MMLL.OL.CutCoherence.OLPosNeg.
Require Import MMLL.OL.CutCoherence.Bipoles.

Require Import Coq.Init.Nat.
Require Import MMLL.Misc.Permutations.

Export ListNotations.
Export LLNotations.
Set Implicit Arguments.

Section LKAdequacy.
Context {SI : Signature}.
Context {USI : UnbSignature}.
Context {USInoD : UnbNoDSignature}.  


(** ** Syntax *)
(** units: true and false *)
Inductive Constants := TT | FF  .
(** conjunction, disjunction and implication *)
Inductive Connectives := AND | OR | IMP  .
(** universal and existential quantifiers *)
Inductive Quantifiers := ALL|SOME .

Inductive UConnectives := .

Instance SimpleOLSig : OLSyntax:=
  {|
    OLType := nat;
    constants := Constants ;
    uconnectives := UConnectives;
    connectives := Connectives ;
    quantifiers := Quantifiers
  |}.


(** ** Inference rules *)
(**  Constants *)
Definition rulesCTE (c:constants) :=
  match c with
  | TT => ZEROTOP
  | FF => TOPZERO
  end.

(**  Binary connectives *)
Definition rulesBC (c :connectives) :=
  match c with
  | AND => PARTENSOR
  | OR =>  TENSORPAR
  | IMP => TENSORPAREXCH
  end.

(**  Unary connectives *)
Definition rulesUC (c :uconnectives) :=
  match c with
  | BOX => QUESTBANG
  end.
  
(**  Quantifiers *)
Definition rulesQD (q :quantifiers) :=
  match q with
  | ALL => ALLSOME
  | SOME => SOMEALL
  end
.

Instance SimpleOORUles : OORules :=
  {|
    rulesCte := rulesCTE ;
    rulesBin := rulesBC;
    rulesU := rulesUC;
    rulesQ := rulesQD
  |}.


(** An inductive definition for LK. This will be used to prove that
the LL encoding is sound and complete *)

Inductive LKSeq : list uexp -> list uexp -> Prop :=
| LKTRUE : forall L L', LKSeq L ((t_cons TT)::L')
| LKFALSE : forall L L', LKSeq (t_cons FF :: L) L' 
| LKinit : forall L L' F,  LKSeq (F:: L) (F::L')

| LKAndL1 : forall L F G L', LKSeq (F :: L) L' -> LKSeq ( (t_bin AND F G) :: L) L'
| LKAndL2 : forall L F G L', LKSeq (G :: L) L' -> LKSeq ( (t_bin AND F G) :: L) L'
| LKAndR : forall L F G L' , LKSeq L (F::L') -> LKSeq L (G::L') -> LKSeq L (t_bin AND F G :: L')

| LKOrL : forall L F G L',  LKSeq (F :: L) L' ->  LKSeq (G :: L) L' -> LKSeq ( (t_bin OR F G) :: L) L'
| LKOrR1 : forall L F G L' , LKSeq L (F::L') -> LKSeq L (t_bin OR F G :: L')
| LKOrR2 : forall L F G L' , LKSeq L (G::L') -> LKSeq L (t_bin OR F G :: L')

| LKImpL : forall A B L1 L2 L1' L2' , LKSeq L1 (A::L1') -> LKSeq (B:: L2) L2' -> LKSeq (t_bin IMP A B ::L1++L2) (L1'++L2')
| LKImpR : forall L A B L' , LKSeq (A:: L) (B::L') ->  LKSeq L (t_bin IMP A B :: L')

| LKAllL : forall L t FX L', uniform FX -> proper t -> LKSeq( FX t :: L) L' -> LKSeq (t_quant ALL FX :: L) L'
| LKAllR : forall L FX L' , uniform FX -> (forall x, proper x -> LKSeq L ((FX x)::L')) -> LKSeq L (t_quant ALL FX :: L')

| LKSomeL : forall L FX L', uniform FX -> (forall x, proper x -> LKSeq (FX x:: L) L') -> LKSeq (t_quant SOME FX :: L) L'
| LKSomeR : forall L FX t L', uniform FX -> proper t -> LKSeq L ((FX t)::L')-> LKSeq L (t_quant SOME FX::L')
(* Explicit exchange *)
| LKExL : forall L L' Delta, Permutation L L' -> LKSeq L Delta -> LKSeq L' Delta
| LKExR : forall L L' Delta, Permutation L L' -> LKSeq Delta L -> LKSeq Delta L'
(* Explicit contraction *)
| LKCtL : forall L L' F, LKSeq (F :: F :: L)  L' -> LKSeq (F :: L)  L'
| LKCtR : forall L L' F, LKSeq L (F :: F :: L')   -> LKSeq L (F :: L')

| LKWkL : forall L L' F, LKSeq L L' -> LKSeq (F :: L)  L'
| LKWkR : forall L L' F, LKSeq L L' -> LKSeq L (F :: L')
.


Hint Constructors LKSeq : core .

Global Instance LKL_morph : 
  Proper ((@Permutation uexp) ==> eq ==> iff) (LKSeq).
Proof.
  unfold Proper; unfold respectful. 
  intros.
  split;intros;subst.
  eapply LKExL;eauto.
  apply Permutation_sym in H.
  eapply LKExL;eauto.
Qed.

Global Instance LKR_morph : 
  Proper (eq ==> (@Permutation uexp)  ==> iff) (LKSeq).
Proof.
  unfold Proper; unfold respectful. 
  intros.
  split;intros;subst.
  eapply LKExR;eauto.
  apply Permutation_sym in H0.
  eapply LKExR;eauto.
Qed.


Theorem LKCtLGen C : forall L L', LKSeq (C ++ C ++ L)  L' -> LKSeq (C ++ L) L'.
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply LKCtL.
  rewrite Permutation_cons_append.
  rewrite Permutation_cons_append.
  do 2 rewrite app_assoc_reverse.
  eapply IHC.
  assert(Hs: Permutation (C ++ C ++ L ++ [a] ++ [a]) ((a :: C) ++ (a :: C) ++ L)) by perm.
  rewrite Hs...
Qed.


Theorem LKCtRGen C : forall L L', LKSeq L (C ++ C ++ L') -> LKSeq L (C ++ L').
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply LKCtR.
  rewrite Permutation_cons_append.
  rewrite Permutation_cons_append.
  do 2 rewrite app_assoc_reverse.
  eapply IHC.
  assert(Hs: Permutation (C ++ C ++ L' ++ [a] ++ [a]) ((a :: C) ++ (a :: C) ++ L')) by perm.
  rewrite Hs...
Qed.

Theorem LKWkLGen C : forall L L', LKSeq L  L' -> LKSeq (C ++ L) L'.
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply LKWkL...
Qed.

Theorem LKWkRGen C : forall L L', LKSeq L  L' -> LKSeq L (C++L').
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply LKWkR...
Qed.

(** Soundness theorem *)
 
Theorem Soundeness: forall L L', 
      LKSeq L L' ->
      isOLFormulaL L ->
      isOLFormulaL L' ->
      seq (OLTheoryC) (CEncode loc (LEncode L) ++ CEncode loc (REncode L')) [] (> []).
Proof with CleanContext;OLSolve;SLSolve.
  intros L L' Hyp isFL isFL'.
  induction Hyp.  
  + (* True on the right *)
    decide3 (makeRuleConstant TT Right)...
    constructor;constructor;auto.
    tensorUnb...
   + (* false on the left *)
    decide3 (makeRuleConstant FF Left)...
    constructor;constructor;auto.
    tensorUnb...
   + (* init *)
    decide3 (RINIT F)...
    apply ooth_initC... 
    tensorUnb...
  + (* ANDL1 *)
    decide3 (makeRuleBinC AND Left F G)...
    apply ooth_rulesC...
    constructor...
    tensorUnb...
    oplus1. 
    rewrite <- (app_nil_l [d| F |]).
    change [d| F |] with ( LEncode [F]). 
    eapply PosSetP...
    inversion isFL...
    inversion H1...
    LLSwap.
    apply weakening...
 + (* ANDL2 *)
    decide3 (makeRuleBinC AND Left F G)...
    constructor;constructor;auto...
    
    tensorUnb...
    
    oplus2.
    rewrite <- (app_nil_l [d| G |]).
    change [d| G |] with ( LEncode [G]). 
    eapply PosSetP...
    inversion isFL...
    inversion H1...
    LLSwap.
    apply weakening...
  + (* And R *)
    decide3 (makeRuleBinC AND Right F G)...
    constructor;constructor;auto...
    
    tensorUnb...
    apply @LinearToClassic with (a:=loc)...
    inversion isFL'...
    inversion H1...
    LLPerm((loc, u| t_bin AND F G |) :: CEncode loc (LEncode L) ++ (loc, u| F |) :: CEncode loc (REncode L')).
    apply weakening...
    apply @LinearToClassic with (a:=loc)...
    inversion isFL'...
    inversion H1...
    LLPerm((loc, u| t_bin AND F G |) :: CEncode loc (LEncode L) ++ (loc, u| G |) :: CEncode loc (REncode L')).
    apply weakening...
  + (* Or L *)
    decide3 (makeRuleBinC OR Left F G)...
    constructor;constructor;auto...
    
    tensorUnb... 
    apply @LinearToClassic with (a:=loc)...
    
    LLPerm((loc, d| t_bin OR F G |) :: (loc, d| F |) :: CEncode loc (LEncode L) ++  CEncode loc (REncode L')).
    apply weakening...
    apply IHHyp1...
    
    apply @LinearToClassic with (a:=loc)...
    
    LLPerm((loc, d| t_bin OR F G |) :: (loc, d| G |) :: CEncode loc (LEncode L) ++  CEncode loc (REncode L')).
    apply weakening...
    apply IHHyp2...
   + (* ORRL1 *)
    decide3 (makeRuleBinC OR Right F G)...
    constructor;constructor;auto...
    tensorUnb...
    
    oplus1.
    apply @LinearToClassic with (a:=loc)...
    LLPerm((loc, u| t_bin OR F G |) :: CEncode loc (LEncode L) ++ (loc, u| F |) ::  CEncode loc (REncode L')).
    apply weakening...
    apply IHHyp...
   + (* ORRL2 *)
    decide3 (makeRuleBinC OR Right F G)...
    constructor;constructor;auto...
    tensorUnb...
    
    oplus2.
    apply @LinearToClassic with (a:=loc)...
    LLPerm((loc, u| t_bin OR F G |) :: CEncode loc (LEncode L) ++ (loc, u| G |) ::  CEncode loc (REncode L')).
    apply weakening...
    apply IHHyp...
  + (* implication left *)
    decide3 (makeRuleBinC IMP Left A B)...
    constructor;constructor;auto...
    tensorUnb...
    apply weakening...
    tensorUnb...
    apply @LinearToClassic with (a:=loc)...
    rewrite !REncodeApp.
    rewrite !LEncodeApp.
    rewrite !CEncodeApp.
    LLPerm (((CEncode loc (LEncode L2) ++ CEncode loc (REncode L2')) ++
    CEncode loc (LEncode L1) ++ (loc, u| A |)::CEncode loc (REncode L1'))).
    apply weakeningGen...
    apply IHHyp1...
    inversion isFL...
    apply @LinearToClassic with (a:=loc)...
    rewrite !REncodeApp.
    rewrite !LEncodeApp.
    rewrite !CEncodeApp.
    LLPerm (((CEncode loc (LEncode L1) ++ CEncode loc (REncode L1')) ++
    (loc, d| B |):: CEncode loc (LEncode L2) ++ CEncode loc (REncode L2'))).
    apply weakeningGen...
    apply IHHyp2...
    inversion isFL...
  + (* implication right *)
   decide3 (makeRuleBinC IMP Right A B)...
   constructor;constructor;auto...
   tensorUnb...
   apply @LinearToClassic with (a:=loc)...
   LLPerm ((loc, u| t_bin IMP A B |)::(loc, d| A |)::CEncode loc (LEncode L) ++ (loc, u| B |) ::CEncode loc (REncode L')).
    apply weakening...
    apply IHHyp... 
  + (* forall left *)
    decide3 (makeRuleQ ALL Left FX)...
    constructor;constructor;auto...
    tensorUnb...
    existential t...
    apply @LinearToClassic with (a:=loc)...
    LLPerm ((loc, d| t_quant ALL FX |)::(loc, d| FX t |)::CEncode loc (LEncode L) ++ CEncode loc (REncode L')).
    apply weakening...
    apply IHHyp...
  + (* forall right *)
    decide3 (makeRuleQ ALL Right FX)...
    constructor;constructor;auto...
    tensorUnb...
    apply @LinearToClassic with (a:=loc)...
    LLPerm ((loc, u| t_quant ALL FX |)::CEncode loc (LEncode L) ++ (loc, u| FX x |)::CEncode loc (REncode L')).
    apply weakening...
    apply H1... 
  + (* existst left *)
    decide3 (makeRuleQ SOME Left FX)...
    constructor;constructor;auto...
    tensorUnb...
    apply @LinearToClassic with (a:=loc)...
    LLPerm ((loc, d| t_quant SOME FX |)::(loc, d| FX x |)::CEncode loc (LEncode L) ++ CEncode loc (REncode L')).
    apply weakening...
    apply H1... 
  + (* exists right *)
    decide3 (makeRuleQ SOME Right FX)...
    constructor;constructor;auto...
    tensorUnb...
   
    existential t.
    apply @LinearToClassic with (a:=loc)...
    LLPerm ((loc, u| t_quant SOME FX |)::CEncode loc (LEncode L) ++ (loc, u| FX t |)::CEncode loc (REncode L')).
    apply weakening...
    apply IHHyp...
  + (* exchange *)
    assert(Hs: Permutation (LEncode L) (LEncode L')).
    eapply Permutation_map;auto.
    apply CEncodePerm with (i:=loc) in Hs. 
    rewrite <- Hs...
    apply IHHyp...
  + 
    assert(Hs: Permutation (REncode L) (REncode L')).
    eapply Permutation_map;auto.
    apply CEncodePerm with (i:=loc) in Hs. 
    rewrite <- Hs...
    apply IHHyp...
  + (* contraction *)
    simpl.
    eapply @contraction with (F:=(loc, d| F |))...
    apply IHHyp... OLSolve.
  + simpl.
    LLPerm((loc, u| F |) ::  CEncode loc (LEncode L) ++ CEncode loc (REncode L')).
    eapply @contraction with (F:=(loc, u| F |))...
    LLPerm(CEncode loc (LEncode L) ++ (loc, u| F |) :: (loc, u| F |) :: CEncode loc (REncode L')).
    apply IHHyp... OLSolve.
  + (* weakening *)
    simpl.
    apply weakening...
    apply IHHyp...
   + (* weakening *)
    simpl.
    LLPerm((loc, u| F |) ::  CEncode loc (LEncode L) ++ CEncode loc (REncode L')).
    apply weakening...
    apply IHHyp...    
Qed.    

(* Require Import Coq.Program.Equality. *)
Theorem Soundeness': forall L L' D D', 
      isOLFormulaL L ->
      isOLFormulaL L' ->
      isOLFormulaL D ->
      isOLFormulaL D' ->
      LKSeq (L++D) (L'++D') ->
      seq (OLTheoryC) (CEncode loc (LEncode L) ++ CEncode loc (REncode L')) (LEncode D ++ REncode D') (> []).
Proof with SLSolve;OLSolve.
  intros L L' D D' isFL isFL' isFD isFD' Hyp.
  eapply PosNegSetT with (a:=loc)...
  eapply Soundeness in Hyp...
  eapply exchangeCC'.
  2:{ exact Hyp. }
  rewrite LEncodeApp.
  rewrite REncodeApp.
  rewrite !CEncodeApp... perm.
Qed.  
  
  (** Completeness theorem *)
Theorem Completeness: forall n L L' D D', 
    isOLFormulaL L ->
    isOLFormulaL L' ->
    isOLFormulaL D ->
    isOLFormulaL D' ->
    seqN (OLTheoryC) n (CEncode loc (LEncode L) ++ CEncode loc (REncode L')) (LEncode D ++  REncode D') (> []) ->
    LKSeq (L++D) (L'++D') .
Proof with CleanContext;SLSolve;OLSolve.
  induction n using strongind; intros L L' D D' HisL HisL' HisD HisD' Hseq; 
  inversion Hseq...
  * apply RemoveNotPos1 in H2;sauto...
    OLSolve. OLSolve.
  * apply InUNotPos in H4;sauto...
    sfold. rewrite secCEncode.
    OLSolve.
    sfold. rewrite secCEncode.
    OLSolve.
  * apply RemoveNotPos2 in H4;sauto...
    sfold. rewrite secCEncode. 
    OLSolve.
    sfold. rewrite secCEncode. 
    OLSolve.
  * inversion H1...
  + inversion H0...
  ++ (* Constant right *)
      apply FocusingRightCteU in H3...
      -
      apply checkEncodeCasesU in H7... 
      (* by cases on C *)
      destruct C...
      apply OLInPermutation' in H5...
      rewrite H5...
      rewrite <- perm_takeit_2...
      inversion H8...
      - destruct C.
        rewrite !secCEncode in H7.
        apply upRight in H7.
        apply OLInPermutation in H7...
        rewrite H3...
        inversion H8...
    ++ (* constant left *)
      apply FocusingLeftCteU in H3...
      -
      apply checkEncodeCasesD in H7... 
      destruct C...
      inversion H8...
      apply OLInPermutationL' in H5...
      rewrite H5...
      rewrite <- perm_takeit_2...
      - destruct C.
       inversion H8...
        rewrite !secCEncode in H7.
        apply downLeft in H7.
        apply OLInPermutationL in H7...
        rewrite H3...
  + inversion H0... 
    ++ (* binary connective right *)
      apply FocusingRightCRuleU in H3...
      -
      apply checkEncodeCasesU in H7...
       (* by cases on C *)
      destruct C...
      { apply AppPARTENSORRightC in H8...
        apply OLInPermutation' in H5...
        rewrite H5 in HisD'.
        rewrite H5...
        rewrite <- perm_takeit_2...
        apply LKAndR...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2)...
        LLExact H9.
        rewrite <- H6...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2)...
        LLExact H10.
        rewrite <- H6...
      }  
      { (*  OR *)
        apply AppTENSORPARRightC in H8...
        apply OLInPermutation' in H5...
        rewrite H5 in HisD'.
        rewrite H5...
        rewrite <- perm_takeit_2...  
        apply LKOrR1...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2)...
        LLExact H8.
        rewrite <- H6...
        
        apply OLInPermutation' in H5...
        rewrite H5 in HisD'.
        rewrite H5...
        rewrite <- perm_takeit_2...  
        apply LKOrR2...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2)...
        LLExact H8.
        rewrite <- H6...
      }
      { (* impl *)
        apply AppTENSORPAREXCHRightC in H8...
        apply OLInPermutation' in H5...
        rewrite H5 in HisD'.
        rewrite H5...
        rewrite <- perm_takeit_2...  
        apply LKImpR...
        
        rewrite !perm_takeit_2...
        eapply H with (m:=x2)...
        LLExact H8.
        rewrite <- H6...
      }
      - destruct C...
      { apply AppPARTENSORRightC in H8...
        rewrite !secCEncode in H7.
        apply upRight in H7.
        apply OLInPermutation in H7...
        rewrite H3...
        apply LKCtR.
        apply LKAndR.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (m:=x0)...
        LLExact H8.
        
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (m:=x0)...
        LLExact H9.
      }
      { rewrite !secCEncode in H7.
        apply upRight in H7.
        apply OLInPermutation in H7...
        
        apply AppTENSORPARRightC in H8...
        
        rewrite H3...
        apply LKCtR.
        apply LKOrR1.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (m:=x1)...
        LLExact H7.
        
        rewrite H3...
        apply LKCtR.
        apply LKOrR2.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (m:=x1)...
        LLExact H7.
     }
     {  rewrite !secCEncode in H7.
        apply upRight in H7.
        apply OLInPermutation in H7...
       
        apply AppTENSORPAREXCHRightC in H8...
        rewrite H3...
        apply LKCtR.
        apply LKImpR.
        rewrite app_comm_cons.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        rewrite perm_takeit_2. 
        eapply H with (m:=x1)...
        LLExact H7.
       }
    ++ (* binary connective left *)
      apply FocusingLeftCRuleU in H3...
      -
      apply checkEncodeCasesD in H7...
       (* by cases on C *)
      destruct C...
      { apply AppPARTENSORLeftC in H8...
        apply OLInPermutationL' in H5...
        rewrite H5 in HisD.
        rewrite H5...
        rewrite <- perm_takeit_2...
        apply LKAndL1...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2)...
        LLExact H8.
        
        apply OLInPermutationL' in H5...
        rewrite H5 in HisD.
        rewrite H5...
        rewrite <- perm_takeit_2...
        apply LKAndL2...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2)...
        LLExact H8.
      }  
      { (*  OR *)
        apply OLInPermutationL' in H5...
        rewrite H5 in HisD.
        rewrite H5...
        rewrite <- perm_takeit_2...
        
        apply AppTENSORPARLeftC in H8... 
          
        apply LKOrL...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2)...
        LLExact H9.
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2)...
        LLExact H10.
      }
      { (* impl *)
        apply OLInPermutationL' in H5...
        rewrite H5 in HisD.
        apply LKCtLGen.
        apply LKCtRGen.
        rewrite H5...
        rewrite <- perm_takeit_2...
        rewrite <- perm_takeit_2...
          
        apply AppTENSORPAREXCHLeftC in H8...   
        rewrite H9 in H6.
        apply destructEncode in H6...
        rewrite H13.
        rewrite H7.
        assert(Hs1:Permutation (t_bin IMP F0 G :: L ++ L ++ x ++ x6) 
              (t_bin IMP F0 G :: (L ++ x) ++ (L++x6))) by perm.
              
        assert(Hs2:Permutation (L' ++ L' ++ x5 ++ x7) ((L' ++ x5) ++ (L'++x7))) by perm.
        
        rewrite Hs1. rewrite Hs2.
        apply LKImpL...
        rewrite Permutation_cons_append.
        rewrite app_assoc_reverse.
        eapply H with (m:=x2)...
        assert(isOLFormulaL x1)...
        OLSolve.
        LLExact H8.
        rewrite REncodeApp.
        rewrite H6...
        rewrite Permutation_cons_append.
        rewrite app_assoc_reverse.
        eapply H with (m:=x2)...
        assert(isOLFormulaL x1)...
        LLExact H11.
        rewrite LEncodeApp.
        rewrite H10...
      }
      - destruct C...
      { rewrite !secCEncode in H7.
        apply downLeft in H7.
        apply OLInPermutationL in H7...
        rewrite H3...
        apply AppPARTENSORLeftC in H8...
        
        apply LKCtL.
        apply LKAndL1.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (m:=x1)...
        
        apply LKCtL.
        apply LKAndL2.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (m:=x1)...
      }
      { rewrite !secCEncode in H7.
        apply downLeft in H7.
        apply OLInPermutationL in H7...
        
        rewrite H3...
        apply AppTENSORPARLeftC in H8...
       
        apply LKCtL.
        apply LKOrL.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (m:=x1)...
     
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (m:=x1)...
     }
     {  rewrite !secCEncode in H7.
        apply downLeft in H7.
        apply OLInPermutationL in H7...
        
        apply LKCtLGen.
        apply LKCtLGen.
        apply LKCtRGen.
        
        
        apply AppTENSORPAREXCHLeftC in H8...
        apply destructEncode in H8...
        rewrite H8.
        rewrite H12.
       
        rewrite H3...
        rewrite perm_takeit_2. 
        apply LKWkLGen.
        
        assert(Hs1:Permutation (t_bin IMP F0 G :: t_bin IMP F0 G :: x0 ++ t_bin IMP F0 G :: x0 ++ x ++ x5) 
                           (t_bin IMP F0 G :: ((t_bin IMP F0 G :: x0) ++ x) ++  ((t_bin IMP F0 G :: x0)) ++ x5)) by perm.
        assert(Hs2:Permutation (L' ++ L' ++ x4 ++ x6) 
                               ((L' ++ x4) ++ (L'++x6))) by perm.
       rewrite Hs1.
        rewrite Hs2.
       clear Hs1 Hs2. 
        rewrite <- H3.
        apply LKImpL.
       
        rewrite perm_takeit_2. 
        eapply H with (m:=x1)...
        LLExact H7.
        rewrite H6...
        
        rewrite perm_takeit_2. 
        eapply H with (m:=x1)...
        LLExact H10.
       }
  + apply FocusingInitRuleU in H3;sauto.
    ++   
      apply destructEncode in H4...
      elim NoDinR with (F:=OO) (L0:=x2).
      rewrite H9...
      elim NoDinR with (F:=OO) (L0:=x2).
      rewrite H9...
       
      assert(REncode x0 = REncode [ OO ]) by auto.
      assert(LEncode x1 = LEncode [ OO ]) by auto.
      apply MapREncodeEqual in H3.
      apply MapLEncodeEqual in H4.
      rewrite H3 in H8.
      rewrite H4 in H5.
      rewrite H5. rewrite H8.
      apply LKWkLGen.
      apply LKWkLGen.
      apply LKWkRGen...
      
      elim NoUinL with (F:=OO) (L0:=x).
      rewrite H6...
   ++  CleanContext.
        rewrite !setUtoGetU in H6...
        rewrite !secCEncode in H6...
        apply downLeft in H6.
        apply OLInPermutationL in H6...
        assert(REncode D' = REncode [ OO ]) by auto.
        apply MapREncodeEqual in H4.
        rewrite H4.
        rewrite H3.
        apply LKWkRGen...
    ++ elim NoUinL with (F:=OO) (L0:=D).
       rewrite H5...
    ++ elim NoDinR with (F:=OO) (L0:=D').
       rewrite H7...
    ++  CleanContext. 
        rewrite !setUtoGetU in H6...
        rewrite !secCEncode in H6...
        apply upRight in H6.
        apply OLInPermutation in H6...
        assert(LEncode D = LEncode [ OO ]) by auto.
        apply MapLEncodeEqual in H5.
        rewrite H5.
        rewrite H3.
        apply LKWkLGen...
    ++  CleanContext. 
        rewrite !setUtoGetU in H6...
        rewrite !secCEncode in H6...
        apply upRight in H6.
        apply OLInPermutation in H6...
        
        CleanContext. 
        rewrite !setUtoGetU in H5...
        rewrite !secCEncode in H5...
         apply downLeft in H5.
        apply OLInPermutationL in H5...
      
        rewrite H4.
        rewrite H3...
  + inversion H0... 
    ++ (* quantifier *)
      apply FocusingRightQU in H3...
      -
      apply checkEncodeCasesU in H8...
      (* by cases on C *)
      destruct C...
      { (* All *)
        apply AppALLSOMERight in H9...
        apply OLInPermutation' in H6...
        rewrite H6 in HisD'.
        rewrite H6...
        
        rewrite <- perm_takeit_2...
        apply LKAllR;intros...
        rewrite perm_takeit_2...
        eapply H with (m:= x2)...
        apply H9 in H3.
        LLExact H3.
        rewrite <- H7...
      }
      { (* Exists *)
        apply AppSOMEALLRight in H9...
        apply OLInPermutation' in H6...
        rewrite H6 in HisD'.
        rewrite H6...
        
        rewrite <- perm_takeit_2...
        eapply LKSomeR;eauto.
        rewrite perm_takeit_2...
        apply H with (m:= x2)...
        LLExact H11.
        rewrite <- H7...
      }
    - destruct C...
      { CleanContext. 
        rewrite !secCEncode in H8...
        apply upRight in H8.
        apply OLInPermutation in H8...
        
        apply LKCtRGen.
        rewrite H3...
        rewrite perm_takeit_2...
        apply LKWkRGen.
        rewrite app_comm_cons.
        rewrite <- H3. 
        apply AppALLSOMERight in H9...
        
        apply LKAllR;auto;intros.
        
        rewrite perm_takeit_2...
        eapply H with (m:=x1)...
        apply H8 in H6.
        LLExact H6.  }
      { rewrite !secCEncode in H8.
        apply upRight in H8.
        apply OLInPermutation in H8...
        
        apply LKCtRGen.
        rewrite H3...
        rewrite perm_takeit_2...
        apply LKWkRGen.
        rewrite app_comm_cons.
        rewrite <- H3. 
        apply AppSOMEALLRight in H9...
        
        
        apply LKSomeR with (t:=x2)... 
        rewrite perm_takeit_2...
        eapply H with (m:=x1)...
        LLExact H10.  }
    ++ (* quantifier *)
      apply FocusingLeftQU in H3...
      -
      apply checkEncodeCasesD in H8...
      (* by cases on C *)
      destruct C...
      { (* All *)
        apply OLInPermutationL' in H6...
        rewrite H6 in HisD.
        rewrite H6...
        
         apply AppALLSOMELeft in H9...
       
        rewrite <- perm_takeit_2...
        apply LKAllL with (t:=x3)... 
        rewrite perm_takeit_2...
        eapply H with (m:= x2)...
        LLExact H11.
      }
      { (* Exists *)
        apply OLInPermutationL' in H6...
        rewrite H6 in HisD.
        rewrite H6...
        
         apply AppSOMEALLLeft in H9...
       
        rewrite <- perm_takeit_2...
        eapply LKSomeL;auto;intros.
        rewrite perm_takeit_2...
        apply H with (m:= x2)...
        apply H9 in H3.
        LLExact H3.
      }
    - destruct C...
      { rewrite !secCEncode in H8.
        apply downLeft in H8.
        apply OLInPermutationL in H8...
        
        apply LKCtLGen.
        rewrite H3...
        rewrite perm_takeit_2...
        apply LKWkLGen.
        rewrite app_comm_cons.
        rewrite <- H3. 
        apply AppALLSOMELeft in H9...
        
        apply LKAllL with (t:=x2)... 
        
        rewrite perm_takeit_2...
        eapply H with (m:=x1)...
     }
      { rewrite !secCEncode in H8.
        apply downLeft in H8.
        apply OLInPermutationL in H8...
        
        apply LKCtLGen.
        rewrite H3...
        rewrite perm_takeit_2...
        apply LKWkLGen.
        rewrite app_comm_cons.
        rewrite <- H3. 
        apply AppSOMEALLLeft in H9...
        
        
        apply LKSomeL;auto;intros.  
        rewrite perm_takeit_2...
        eapply H with (m:=x1)...
         }
    +
       apply FocusingPOSU in H3...
   
    ++  apply checkEncodeCasesD in H6... 
        apply OLInPermutationL' in H4...
        rewrite H4.
         rewrite <- perm_takeit_2...
       rewrite app_comm_cons.
        eapply H with (m:=x)...
        LLExact H7.
    ++  rewrite !secCEncode in H6.
        apply downLeft in H6.
        apply OLInPermutationL in H6...
        apply LKCtLGen.
        rewrite H3.
        assert(Permutation ((OO :: x0) ++ (OO :: x0) ++ D) (x0++ (OO :: (OO :: x0)) ++ D)) by perm.
        rewrite H4.
        apply LKWkLGen.
        rewrite <- H3.
        eapply H with  (m:=x)...
        LLExact H7.
    + apply FocusingNEGU in H3...
   
    ++  apply checkEncodeCasesU in H6... 
        apply OLInPermutation' in H4...
        rewrite H4.
         rewrite <- perm_takeit_2...
       rewrite app_comm_cons.
        eapply H with  (m:=x)...
        LLExact H7.
    ++  rewrite !secCEncode in H6.
        apply upRight in H6.
        apply OLInPermutation in H6...
        apply LKCtRGen.
        rewrite H3.
        assert(Permutation ((OO :: x0) ++ (OO :: x0) ++ D') (x0++ (OO :: (OO :: x0)) ++ D')) by perm.
        rewrite H4.
        apply LKWkRGen.
        rewrite <- H3.
        eapply H with (m:=x)...
        LLExact H7.
   
Qed.
 
Theorem AdequacyLK:  forall L L' D D', 
   isOLFormulaL L ->
   isOLFormulaL L' ->
   isOLFormulaL D ->
   isOLFormulaL D' ->
   (LKSeq (L ++ D) (L' ++ D') <->
          seq OLTheoryC
         (CEncode loc (LEncode L) ++ CEncode loc (REncode L'))
         (LEncode D ++ REncode D') (> []) ).
Proof with sauto.
  intros.
  split;intros.
  + apply Soundeness'... 
  + apply seqtoSeqN in H3... 
    apply Completeness in H3...
Qed.

End LKAdequacy.
