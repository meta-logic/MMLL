(** * System LK for classical logic encoded as an LL theory

This file encodes the inference rules of the system LK. Since the
rules used are cut-coherent, the cut-elimination theorem applies for
this system.
 *)


Require Import MMLL.OL.CutCoherence.OLTactics.
Require Import MMLL.OL.CutCoherence.OLPosNeg.
Require Import MMLL.OL.CutCoherence.LK.LKBipoles.
Require Import MMLL.SL.FLLReasoning.

Require Import Coq.Init.Nat.
Require Import MMLL.Misc.Permutations.

Export ListNotations.
Export LLNotations.
Set Implicit Arguments.

Section LKAdequacy.
Context {SI : Signature}.
Context {USI : UnbSignature}.
Context {USInoD : UnbNoDSignature}.  

(** An inductive definition for LK. This will be used to prove that
the LL encoding is sound and complete *)

Inductive LKSeq : list uexp -> list uexp -> Prop :=
| LKTRUE : forall L L', LKSeq L ((t_cons TT)::L')
| LKFALSE : forall L L', LKSeq (t_cons FF :: L) L' 
| LKinit : forall L L' F,  LKSeq (F:: L) (F::L')

| LKAndL1 : forall L F G L', LKSeq (F :: L) L' -> LKSeq ( (t_bin AND F G) :: L) L'
| LKAndL2 : forall L F G L', LKSeq (G :: L) L' -> LKSeq ( (t_bin AND F G) :: L) L'
| LKAndR : forall L F G L' , LKSeq L (F::L') -> LKSeq L (G::L') -> LKSeq L (t_bin AND F G :: L')

| LKOrL : forall L F G L',  LKSeq (F :: L) L' ->  LKSeq (G :: L) L' -> LKSeq ( (t_bin OR F G) :: L) L'
| LKOrR1 : forall L F G L' , LKSeq L (F::L') -> LKSeq L (t_bin OR F G :: L')
| LKOrR2 : forall L F G L' , LKSeq L (G::L') -> LKSeq L (t_bin OR F G :: L')

| LKImpL : forall A B L1 L2 L1' L2' , LKSeq L1 (A::L1') -> LKSeq (B:: L2) L2' -> LKSeq (t_bin IMP A B ::L1++L2) (L1'++L2')
| LKImpR : forall L A B L' , LKSeq (A:: L) (B::L') ->  LKSeq L (t_bin IMP A B :: L')

| LKAllL : forall L t FX L', uniform FX -> proper t -> LKSeq( FX t :: L) L' -> LKSeq (t_quant ALL FX :: L) L'
| LKAllR : forall L FX L' , uniform FX -> (forall x, proper x -> LKSeq L ((FX x)::L')) -> LKSeq L (t_quant ALL FX :: L')

| LKSomeL : forall L FX L', uniform FX -> (forall x, proper x -> LKSeq (FX x:: L) L') -> LKSeq (t_quant SOME FX :: L) L'
| LKSomeR : forall L FX t L', uniform FX -> proper t -> LKSeq L ((FX t)::L')-> LKSeq L (t_quant SOME FX::L')
(* Explicit exchange *)
| LKExL : forall L L' Delta, Permutation L L' -> LKSeq L Delta -> LKSeq L' Delta
| LKExR : forall L L' Delta, Permutation L L' -> LKSeq Delta L -> LKSeq Delta L'
(* Explicit contraction *)
| LKCtL : forall L L' F, LKSeq (F :: F :: L)  L' -> LKSeq (F :: L)  L'
| LKCtR : forall L L' F, LKSeq L (F :: F :: L')   -> LKSeq L (F :: L')

| LKWkL : forall L L' F, LKSeq L L' -> LKSeq (F :: L)  L'
| LKWkR : forall L L' F, LKSeq L L' -> LKSeq L (F :: L')
.


Hint Constructors LKSeq : core .

Global Instance LKL_morph : 
  Proper ((@Permutation uexp) ==> eq ==> iff) (LKSeq).
Proof.
  unfold Proper; unfold respectful. 
  intros.
  split;intros;subst.
  eapply LKExL;eauto.
  apply Permutation_sym in H.
  eapply LKExL;eauto.
Qed.

Global Instance LKR_morph : 
  Proper (eq ==> (@Permutation uexp)  ==> iff) (LKSeq).
Proof.
  unfold Proper; unfold respectful. 
  intros.
  split;intros;subst.
  eapply LKExR;eauto.
  apply Permutation_sym in H0.
  eapply LKExR;eauto.
Qed.


Theorem LKCtLGen C : forall L L', LKSeq (C ++ C ++ L)  L' -> LKSeq (C ++ L) L'.
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply LKCtL.
  rewrite Permutation_cons_append.
  rewrite Permutation_cons_append.
  do 2 rewrite app_assoc_reverse.
  eapply IHC.
  assert(Hs: Permutation (C ++ C ++ L ++ [a] ++ [a]) ((a :: C) ++ (a :: C) ++ L)) by perm.
  rewrite Hs...
Qed.


Theorem LKCtRGen C : forall L L', LKSeq L (C ++ C ++ L') -> LKSeq L (C ++ L').
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply LKCtR.
  rewrite Permutation_cons_append.
  rewrite Permutation_cons_append.
  do 2 rewrite app_assoc_reverse.
  eapply IHC.
  assert(Hs: Permutation (C ++ C ++ L' ++ [a] ++ [a]) ((a :: C) ++ (a :: C) ++ L')) by perm.
  rewrite Hs...
Qed.

Theorem LKWkLGen C : forall L L', LKSeq L  L' -> LKSeq (C ++ L) L'.
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply LKWkL...
Qed.

Theorem LKWkRGen C : forall L L', LKSeq L  L' -> LKSeq L (C++L').
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply LKWkR...
Qed.

(** Soundness theorem *)
 
 Ltac solveBipole :=
 match goal with
| [H: context[BinBipole] |- _] => inversion H 
| [H: context[CteBipole] |- _] => inversion H
| [H: context[QuBipole] |- _] => inversion H  end.
 
 Ltac solveInitLoc :=
simpl;
match goal with
  | [  |- seq _ ((loc,atom ?A)::?B) [] (DW (perp ?A))] => init2 loc B;solveSignature1
    | [  |- seq _ (?B++[(loc,atom ?A)]) [] (DW (perp ?A))] => init2 loc B;solveSignature1
    | [  |- seq _ (?X::?B++[(loc,atom ?A)]) [] (DW (perp ?A))] => init2 loc (X::B);solveSignature1
    | [  |- seq _ (?B++(loc,atom ?A)::?E) [] (DW (perp ?A))] => init2 loc (B++E);solveSignature1   
    | [ |- seq _ (?X::?B++(loc,atom ?A)::?E) [] (DW (perp ?A))] => init2 loc (X::B++E);solveSignature1   
  
    | [ H: Permutation ((loc,atom _)::?B) ?D |- seq  _ ?D [] (DW (perp ?A))] => init2 loc B
    | [ H: Permutation (?B++[(loc,atom ?A)]) ?D |- seq _ ?D [] (DW (perp ?A))] => init2 loc B
    | [ H: Permutation (?B++(loc,atom ?A)::?E) ?D |- seq _ ?D [] (DW (perp ?A))] => init2 loc (B++E)

    | [ H: Permutation ?D ((loc,atom ?A)::?B)  |- seq _ ?D [] (DW (perp ?A))] => init2 loc B
    | [ H: Permutation ?D (?B++[(loc,atom ?A)])  |- seq _ ?D [] (DW (perp ?A))] => init2 loc B
    | [ H: Permutation ?D (?B++(loc,atom ?A)::?E)  |- seq _ ?D [] (DW (perp ?A))] => init2 loc (B++E)
 
 end.

 

Tactic Notation "Bipole"  constr(B) constr(S):=
        match B with 
        | TT => TFocus (CteBipole TT_BODY S)
        | FF => TFocus (CteBipole FF_BODY S)
end;[do 2 constructor;OLSolve | solveBipole | ].

Tactic Notation "Bipole"  constr(B) constr(S) constr(F) constr(G):=
        match B with 
        | AND => TFocus (BinBipole AND_BODY S F G)
        | OR => TFocus (BinBipole OR_BODY S F G)
        | IMP => TFocus (BinBipole IMP_BODY S F G)
end;[do 2 constructor;OLSolve | solveBipole | ].


Tactic Notation "Bipole"  constr(B) constr(S) constr(FX) :=
        match B with 
        | ALL => TFocus (QuBipole ALL_BODY S FX)
        | SOME => TFocus (QuBipole SOME_BODY S FX)
end;[do 2 constructor;OLSolve | solveBipole | ].
  

Theorem Soundeness: forall a L L', 
      LKSeq L L' ->
      isOLFormulaL L ->
      isOLFormulaL L' ->
      mt a = true ->
      seq (LK a) (CEncode a (LEncode L) ++ CEncode a (REncode L')) [] (UP []).
Proof with CleanContext;OLSolve;solveSE.
  intros *. 
  intros Hyp isFL isFL' Ha.
  induction Hyp.
  + (* True on the right *)
  Bipole TT Right.
  LLTensor;[simpl; solveLL | ]. 
  simpl...
   + (* false on the left *)
  Bipole FF Left.
  LLTensor;[simpl; solveLL | ]. 
  simpl...
   + (* init *)
    TFocus (RINIT F)...
    apply ooth_initC...
    inversion H. 
    LLTensor...
    simpl; solveLL.
    simpl; solveLL.
  + (* ANDL1 *)
   Bipole AND Left F G.
   LLTensor;[simpl; solveLL | ]. 
   LLPlusL.
   LLRelease. 
   LLStore. 
   rewrite <- (app_nil_l [d| F |]).
   change [d| F |] with ( LEncode [F]). 
   eapply PosSetP with (a:=a)...
   intro; intros...
   inversion isFL...
   inversion H1...
   simpl...
   LLSwap.
   apply weakening...
   solveSignature1.
 + (* ANDL2 *)
    Bipole AND Left F G.
    LLTensor;[simpl; solveLL | ]. 
    LLPlusR.
    LLRelease.
    LLStore.
    rewrite <- (app_nil_l [d| G |]).
    change [d| G |] with ( LEncode [G]). 
    eapply PosSetP with (a:=a)...
    intro; intros...
    inversion isFL...
    inversion H1...
    simpl.
    LLSwap.
    apply weakening...
    solveSignature1.
  + (* And R *)
    Bipole AND Right F G.
    LLTensor;[simpl; solveLL | ]. 
    simpl.
    LLRelease. 
    LLWith. all: LLStore.
    PosNegAll a.
    1-2: intro; intros...
    OLSolve.
    inversion isFL'...
    inversion H1...
    LLPerm((a, u| t_bin AND F G |) :: CEncode a (LEncode L) ++ (a, u| F |) :: CEncode a (REncode L')).
    apply weakening...
    solveSignature1.
    PosNegAll a. 
    1-2: intro; intros...
    OLSolve.
    inversion isFL'...
    inversion H1...
    LLPerm((a, u| t_bin AND F G |) :: CEncode a (LEncode L) ++ (a, u| G |) :: CEncode a (REncode L')).
    apply weakening...
    solveSignature1.
  + (* Or L *)
    Bipole OR Left F G.
    LLTensor;[simpl; solveLL | ]. 
    simpl. 
    LLRelease. 
    LLWith. 
    all: LLStore.
    PosNegAll a.
    1-2: intro; intros...
    OLSolve.
    LLPerm((a, d| t_bin OR F G |) :: (a, d| F |) :: CEncode a (LEncode L) ++  CEncode a (REncode L')).
    apply weakening...
    solveSignature1.
    apply IHHyp1...
    
    PosNegAll a.
    1-2: intro; intros...
    OLSolve.
    
    LLPerm((a, d| t_bin OR F G |) :: (a, d| G |) :: CEncode a (LEncode L) ++  CEncode a (REncode L')).
    apply weakening...
    solveSignature1.
    apply IHHyp2...
   + (* ORRL1 *)
    Bipole OR Right F G.
    LLTensor;[simpl; solveLL | ]. 
    LLPlusL.
    LLRelease. 
    LLStore.
    PosNegAll a.
    1-2: intro; intros...
    OLSolve.
   
    LLPerm((a, u| t_bin OR F G |) :: CEncode a (LEncode L) ++ (a, u| F |) ::  CEncode a (REncode L')).
    apply weakening...
    solveSignature1.
    apply IHHyp...
   + (* ORRL2 *)
    Bipole OR Right F G.
    LLTensor;[simpl; solveLL | ]. 
    LLPlusR.
    LLRelease. 
    LLStore.
    PosNegAll a.
    1-2: intro; intros...
    OLSolve.

    LLPerm((a, u| t_bin OR F G |) :: CEncode a (LEncode L) ++ (a, u| G |) ::  CEncode a (REncode L')).
    apply weakening...
    solveSignature1.
    apply IHHyp...
  + (* implication left *)
  TFocus (BinBipole IMP_BODY Left A B);[do 2 constructor;OLSolve | solveBipole | ].
    LLTensor;[simpl; solveLL | ]. 
    simpl.
    apply weakening...
    solveSignature1.
   LLTensor.
   all: LLRelease;LLStore.
    PosNegAll a.
    1-2: intro; intros...
    OLSolve.

    rewrite !REncodeApp.
    rewrite !LEncodeApp.
    rewrite !CEncodeApp.
    LLPerm (((CEncode a (LEncode L2) ++ CEncode a (REncode L2')) ++
    CEncode a (LEncode L1) ++ (a, u| A |)::CEncode a (REncode L1'))).
    apply weakeningGen...
    apply IHHyp1...
    inversion isFL...

    PosNegAll a.
    1-2: intro; intros...
    OLSolve.
    
    rewrite !REncodeApp.
    rewrite !LEncodeApp.
    rewrite !CEncodeApp.
    LLPerm (((CEncode a (LEncode L1) ++ CEncode a (REncode L1')) ++
    (a, d| B |):: CEncode a (LEncode L2) ++ CEncode a (REncode L2'))).
    apply weakeningGen...
    apply IHHyp2...
    inversion isFL...
  + (* implication right *)
   TFocus (BinBipole IMP_BODY Right A B);[do 2 constructor;OLSolve | solveBipole | ].
   LLTensor;[ simpl;solveLL | ]. 
   simpl. LLRelease.
   LLPar. LLStore. LLStore.
   
    PosNegAll a.
    1-2: intro; intros...
    OLSolve.
   
   LLPerm ((a, u| t_bin IMP A B |)::(a, d| A |)::CEncode a (LEncode L) ++ (a, u| B |) ::CEncode a (REncode L')).
    apply weakening...
    solveSignature1.
    apply IHHyp... 
  + (* forall left *)
    Bipole ALL Left FX. 
     LLTensor;[ simpl; solveLL | ]. 
    LLExists t...
    LLRelease. LLStore.
    
    PosNegAll a.
    1-2: intro; intros...
    OLSolve.
    solveQF.
    
    LLPerm ((a, d| t_quant ALL FX |)::(a, d| FX t |)::CEncode a (LEncode L) ++ CEncode a (REncode L')).
    apply weakening...
    solveSignature1.
    apply IHHyp...
    solveQF.
  + (* forall right *)
    Bipole ALL Right FX. 
     LLTensor;[simpl; solveLL | ]. 
    simpl. LLRelease.
    LLForall.
    constructor.
    constructor.
    inversion isFL'... 
    LLStore.
    PosNegAll a.
    1-2: intro; intros...
    OLSolve.
    solveQF.
   
    LLPerm ((a, u| t_quant ALL FX |)::CEncode a (LEncode L) ++ (a, u| FX x |)::CEncode a (REncode L')).
    apply weakening...
    solveSignature1.
    apply H1...
    solveQF.
   + (* existst left *)
    Bipole SOME Left FX.
     LLTensor;[simpl; solveLL | ]. 
     simpl. LLRelease.
    LLForall.
    constructor.
    constructor.
    inversion isFL'... 
    LLStore.
    PosNegAll a.
    1-2: intro; intros...
    OLSolve.
    solveQF.
    
    LLPerm ((a, d| t_quant SOME FX |)::(a, d| FX x |)::CEncode a (LEncode L) ++ CEncode a (REncode L')).
    apply weakening...
    solveSignature1.
    apply H1...
    solveQF.
  + (* exists right *)
    Bipole SOME Right FX. 
    LLTensor;[simpl; solveLL | ]. 
    LLExists t.
    LLRelease. LLStore.
    PosNegAll a.
    1-2: intro; intros...
    OLSolve.
    solveQF.

    LLPerm ((a, u| t_quant SOME FX |)::CEncode a (LEncode L) ++ (a, u| FX t |)::CEncode a (REncode L')).
    apply weakening...
    solveSignature1.
    apply IHHyp...
    solveQF.
  + (* exchange *)
    assert(Hs: Permutation (LEncode L) (LEncode L')).
    eapply Permutation_map;auto.
    apply CEncodePerm with (i:=a) in Hs. 
    rewrite <- Hs...
    apply IHHyp...
  + 
    assert(Hs: Permutation (REncode L) (REncode L')).
    eapply Permutation_map;auto.
    apply CEncodePerm with (i:=a) in Hs. 
    rewrite <- Hs...
    apply IHHyp...
  + (* contraction *)
    simpl.
    eapply @contraction with (F:=(a, d| F |))...
    solveSignature1.
    apply IHHyp... OLSolve.
  + simpl.
    LLPerm((a, u| F |) ::  CEncode a (LEncode L) ++ CEncode a (REncode L')).
    eapply @contraction with (F:=(a, u| F |))...
    solveSignature1.
    LLPerm(CEncode a (LEncode L) ++ (a, u| F |) :: (a, u| F |) :: CEncode a (REncode L')).
    apply IHHyp... OLSolve.
  + (* weakening *)
    simpl.
    apply weakening...
    solveSignature1.
    apply IHHyp...
   + (* weakening *)
    simpl.
    LLPerm((a, u| F |) ::  CEncode a (LEncode L) ++ CEncode a (REncode L')).
    apply weakening...
    solveSignature1.
    apply IHHyp...    
Qed.    

(* Require Import Coq.Program.Equality. *)
Theorem Soundeness': forall a L L' D D', 
      isOLFormulaL L ->
      isOLFormulaL L' ->
      isOLFormulaL D ->
      isOLFormulaL D' ->
      mt a = true ->
      LKSeq (L++D) (L'++D') ->
      seq (LK a) (CEncode a (LEncode L) ++ CEncode a (REncode L')) (LEncode D ++ REncode D') (UP []).
Proof with solveSE;OLSolve.
  intros *.
  intros isFL isFL' isFD isFD' Ha Hyp.
  PosNegAll a...
  1-2: intro; intros...
  OLSolve. OLSolve.
  eapply Soundeness in Hyp...
  eapply exchangeCC'.
  2:{ exact Hyp. }
  rewrite LEncodeApp.
  rewrite REncodeApp.
  rewrite !CEncodeApp... perm.
 auto.
Qed.  
  
  
  Lemma PermSecond (L1 L2: list TypedFormula): 
     Permutation L1 L2 ->
     Permutation (second L1) (second L2) .
  Proof.
  eapply Permutation_map.   
  Qed.
 
   Theorem FocusingForallUP :
    forall n th (y: expr Syntax.con) FX D G, proper y ->
    seqN th n G D (DW (∀{ fun x : expr Syntax.con => u| FX x |})) ->
      exists m , n =  S (S (S m))  /\ seqN th m G (u| FX y |::D) (UP [ ]).
  Proof with sauto.
    intros.
    inversion H0... 
    inversion H6...
    solveF.
    specialize (H9 _ H).
    inversion H9...
    eexists n0.
    split;eauto.
  Qed.
         
   Theorem FocusingForallDW :
    forall n th (y: expr Syntax.con) FX D G, proper y ->
    seqN th n G D (DW (∀{ fun x : expr Syntax.con => d| FX x |})) ->
      exists m , n =  S (S (S m))  /\ seqN th m G (d| FX y |::D) (UP [ ]).
  Proof with sauto.
    intros.
    inversion H0... 
    inversion H6...
    solveF.
    specialize (H9 _ H).
    inversion H9...
    eexists n0.
    split;eauto.
  Qed.

   Theorem FocusingExistsUP :
    forall n th FX D G, 
    seqN th n G D (DW (∃{ fun x : expr Syntax.con => u| FX x |})) ->
      exists m t, n =  S (S (S m))  /\ proper t /\ seqN th m G (u| FX t |::D) (UP [ ]).
  Proof with sauto.
    intros.
    inversion H... solveF. 
    inversion H6...
    inversion H8...
    eexists n0, t.
    split;eauto.
  Qed.

   Theorem FocusingExistsDW :
    forall n th FX D G, 
    seqN th n G D (DW (∃{ fun x : expr Syntax.con => d| FX x |})) ->
      exists m t, n =  S (S (S m))  /\ proper t /\ seqN th m G (d| FX t |::D) (UP [ ]).
  Proof with sauto.
    intros.
    inversion H... solveF. 
    inversion H6...
    inversion H8...
    eexists n0, t.
    split;eauto.
  Qed.

  (** Completeness theorem *)
Theorem Completeness: forall n a L L' D D', 
    isOLFormulaL L ->
    isOLFormulaL L' ->
    isOLFormulaL D ->
    isOLFormulaL D' ->
    mt a = true ->
    seqN (LK a) n (CEncode a (LEncode L) ++ CEncode a (REncode L')) (LEncode D ++  REncode D') (UP []) ->
    LKSeq (L++D) (L'++D') .
Proof with CleanContext;solveSE;OLSolve.
  induction n using strongind; intros *; 
  intros HisL HisL' HisD HisD' Ha Hseq; 
  inversion Hseq...
  * apply RemoveNotPos1 in H2;sauto...
    inversion H0; inversion H1...
    OLSolve. OLSolve.
  * apply InUNotPos in H4;sauto...
     rewrite secondApp. 
     rewrite !secCEncode...
    OLSolve. OLSolve.
  * apply RemoveNotPos2 in H4;sauto...
     rewrite secondApp. 
     rewrite !secCEncode...
    OLSolve. OLSolve.
  * inversion H1...
  + inversion H0...
  ++ (* Constant right *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesU in H8... 
      apply OLInPermutation' in H5...
      rewrite H5...
      rewrite <- perm_takeit_2...
      -
      simpl in H9.
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9...
      symmetry in H9.
      apply checkEncodeCasesU in H9...
      apply OLInPermutation' in H5...
      rewrite H5...
      rewrite <- app_comm_cons...
    ++ (* constant left *)
      apply BipoleReasoning in H3...
      - simpl in H7.  
         inversion H7...
      - simpl in H7.  
         inversion H7...

    ++ (* constant left *)
      apply BipoleReasoning in H3...
      - simpl in H7.  
         inversion H7...
      - simpl in H7.  
         inversion H7...
  ++ (* Constant right *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesD in H8... 
      apply OLInPermutationL' in H5...
      rewrite H5...
      rewrite <- perm_takeit_2...
      -
      simpl in H9.
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9...
      symmetry in H9.
      apply checkEncodeCasesD in H9...
      apply OLInPermutationL' in H5...
      rewrite H5...
      rewrite <- app_comm_cons...
         
  + inversion H0... 
    ++ (* binary connective right *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesU in H8...
      apply FocusingWith in H7...
      apply OLInPermutation' in H5...
        rewrite H5 in HisD'.
        rewrite H5...
      rewrite <- perm_takeit_2...
      apply LKAndR...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H9.
        rewrite <- H6...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H10.
        rewrite <- H6...
       -
      apply FocusingWith in H7...
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9...
      symmetry in H9.
      apply checkEncodeCasesU in H9...
      apply OLInPermutation' in H5...
      rewrite H5 in HisL'.
      rewrite H5...
      rewrite <- app_comm_cons.
      apply LKCtR.
      rewrite app_comm_cons.
      rewrite <- H5...
      apply LKAndR.
      rewrite <- Permutation_midle.
      eapply H with (m:=x2) (a:=a)...
      LLExact H8.
      simpl...
      rewrite <- Permutation_midle.
      eapply H with (m:=x2) (a:=a)...
      LLExact H10.
      simpl...
    ++ (* binary connective right *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesD in H8...
      apply OLInPermutationL' in H5...
     apply FocusingPlus in H7...
      rewrite H5 in HisD.
      rewrite H5...
      rewrite <- perm_takeit_2...
      apply LKAndL1...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H8.
        rewrite <- H6...
        
      rewrite H5 in HisD.
      rewrite H5...
      rewrite <- perm_takeit_2...
      apply LKAndL2...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H8.
        rewrite <- H6...
       -
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9...
      symmetry in H9.
      apply checkEncodeCasesD in H9...
      apply OLInPermutationL' in H5...
      rewrite H5 in HisL.
      rewrite H5...
      rewrite <- app_comm_cons.
      apply LKCtL.
      rewrite app_comm_cons.
      rewrite <- H5...
      
      apply FocusingPlus in H7...
      
      apply LKAndL1.
      rewrite <- Permutation_midle.
      eapply H with (m:=x3) (a:=a)...
      
      apply LKAndL2.
      rewrite <- Permutation_midle.
      eapply H with (m:=x3) (a:=a)...
    ++ (* binary connective right *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesU in H8...
      apply OLInPermutation' in H5...
     apply FocusingPlus in H7...
      rewrite H5 in HisD'.
      rewrite H5...
      rewrite <- perm_takeit_2...
      apply LKOrR1...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H8.
        rewrite <- H6...
        
      rewrite H5 in HisD'.
      rewrite H5...
      rewrite <- perm_takeit_2...
      apply LKOrR2...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H8.
        rewrite <- H6...
       -
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9...
      symmetry in H9.
      apply checkEncodeCasesU in H9...
      apply OLInPermutation' in H5...
      rewrite H5 in HisL'.
      rewrite H5...
      rewrite <- app_comm_cons.
      apply LKCtR.
      rewrite app_comm_cons.
      rewrite <- H5...
      
      apply FocusingPlus in H7...
      
      apply LKOrR1.
      rewrite <- Permutation_midle.
      eapply H with (m:=x3) (a:=a)...
      LLExact H9.
      simpl...
      apply LKOrR2.
      rewrite <- Permutation_midle.
      eapply H with (m:=x3) (a:=a)...
      LLExact H9.
      simpl...
    ++ (* binary connective right *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesD in H8...
      apply FocusingWith in H7...
      apply OLInPermutationL' in H5...
        rewrite H5 in HisD.
        rewrite H5...
      rewrite <- perm_takeit_2...
      apply LKOrL...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H9.
        rewrite <- H6...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H10.
        rewrite <- H6...
       -
      apply FocusingWith in H7...
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9...
      symmetry in H9.
      apply checkEncodeCasesD in H9...
      apply OLInPermutationL' in H5...
      rewrite H5 in HisL.
      rewrite H5...
      rewrite <- app_comm_cons.
      apply LKCtL.
      rewrite app_comm_cons.
      rewrite <- H5...
      apply LKOrL.
      rewrite <- Permutation_midle.
      eapply H with (m:=x2) (a:=a)...
      rewrite <- Permutation_midle.
      eapply H with (m:=x2) (a:=a)...

    ++ (* binary connective right *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesU in H8...
      apply OLInPermutation' in H5...
     apply FocusingPar in H7...
      rewrite H5 in HisD'.
      rewrite H5...
      rewrite <- perm_takeit_2...
      apply LKImpR...
        
      do  2 rewrite perm_takeit_2...
        eapply H with (m:=x2) (a:=a)...
        LLExact H8.
        rewrite <- H6...
       -
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9...
      symmetry in H9.
      apply checkEncodeCasesU in H9...
      apply OLInPermutation' in H5...
      rewrite H5 in HisL'.
      rewrite H5...
      rewrite <- app_comm_cons.
      apply LKCtR.
      rewrite app_comm_cons.
      rewrite <- H5...
      
      apply FocusingPar in H7...
      apply LKImpR...
      
      do 2 rewrite <- Permutation_midle.
      eapply H with (m:=x3) (a:=a)...
      LLExact H9.
      simpl...
    ++ (* binary connective right *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesD in H8...
      apply OLInPermutationL' in H5...
        rewrite H5 in HisD.
      rewrite H5...
      rewrite <- perm_takeit_2...
    
       apply FocusingTensor in H7...
       rewrite H9 in H6.
       apply destructEncode in H6...
       assert(LKSeq (L++x) (L'++F0 :: x5)).
        eapply H with (m:=x2) (a:=a)...
        assert(isOLFormulaL x1) by OLSolve.
        OLSolve.
      LLExact H8.
      rewrite H6...
      assert(LKSeq (L++G :: x6) (L'++x7)).
        eapply H with (m:=x2) (a:=a)...
         assert(isOLFormulaL x1) by OLSolve.
        OLSolve.
      LLExact H11.
      rewrite H10...
      assert(LKSeq (t_bin IMP F0 G :: (L++x) ++ (L++x6)) ((L'++x5) ++ (L' ++ x7))).
      apply LKImpL...
      rewrite <- Permutation_midle...
      rewrite <- Permutation_midle...
      rewrite <- Permutation_midle...
      apply LKCtLGen.
      apply LKCtRGen.
      eapply LKExR with (L:=(L' ++ x5) ++ L' ++ x7)...
      rewrite H13...
      eapply LKExL with (L:=t_bin IMP_BODY.(con) F0 G :: (L ++ x) ++ L ++ x6)...
      rewrite H7...
      -
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9...
      symmetry in H9.
      apply checkEncodeCasesD in H9...
      apply OLInPermutationL' in H5...
        rewrite H5 in HisL.
      rewrite H5...
      
      rewrite <- app_comm_cons.
      
       apply FocusingTensor in H7...
       apply destructEncode in H10...
       assert(LKSeq (L++x) (L'++F0 :: x6)).
        eapply H with (m:=x3) (a:=a)...
      LLExact H9.
      rewrite H7...
      assert(LKSeq (L++G :: x7) (L'++x8)).
        eapply H with (m:=x3) (a:=a)...
      LLExact H12.
      rewrite H11...
      
      assert(LKSeq (t_bin IMP F0 G :: (L++x) ++ (L++x7)) ((L'++x6) ++ (L' ++ x8))).
      apply LKImpL...
      1-2: rewrite <- Permutation_midle...
      apply LKCtL.
      rewrite app_comm_cons.
      rewrite <- H5...
      rewrite <- Permutation_midle...
      apply LKCtLGen.
      apply LKCtRGen.
      eapply LKExR with (L:=(L' ++ x6) ++ L' ++ x8)...
      rewrite H14...
      eapply LKExL with (L:=t_bin IMP_BODY.(con) F0 G :: (L ++ x) ++ L ++ x7)...
      rewrite H10...
   + apply FocusingInitRuleU in H3;sauto.
    ++   
      change [u| OO |; d| OO |] with ([u| OO |] ++ [d| OO |]) in H4. 
      apply destructEncode in H4...
      apply map_eq_cons in H9...
      apply map_eq_cons in H9...
      apply map_eq_cons in H10...
      apply map_eq_cons in H7...
      apply map_eq_nil in H9...
      apply map_eq_nil in H6...
      inversion H11... inversion H10...
      
      rewrite Permutation_app_comm.
      simpl.
      rewrite Permutation_app_comm.
      simpl...
      
      apply map_eq_cons in H7...
      apply map_eq_cons in H6...
   ++  CleanContext.
        apply map_eq_cons in H8...
        apply map_eq_nil in H5...
        inversion H9...
        
        apply PermSecond in H6.
      rewrite !secondApp in H6.
      rewrite !secCEncode in H6.
      simpl in H6...
      symmetry in H6.
      apply checkEncodeCasesD in H6...
      apply OLInPermutationL' in H4...
      rewrite Permutation_app_comm.
      rewrite H4;simpl...
    ++ apply map_eq_cons in H5...
    ++ apply map_eq_cons in H8...
    ++  CleanContext.
        apply map_eq_cons in H5...
        apply map_eq_nil in H8...
        inversion H9...
        
        apply PermSecond in H6.
      rewrite !secondApp in H6.
      rewrite !secCEncode in H6.
      simpl in H6...
      symmetry in H6.
      apply checkEncodeCasesU in H6...
      apply OLInPermutation' in H4...
      rewrite Permutation_app_comm.
      rewrite H4;simpl...
     ++ 
      apply map_eq_nil in H3, H8...
         apply PermSecond in H6.
      rewrite !secondApp in H6.
      rewrite !secCEncode in H6.
      simpl in H6...
      symmetry in H6.
      apply checkEncodeCasesU in H6...
      
         apply PermSecond in H4.
      rewrite !secondApp in H4.
      rewrite !secCEncode in H4.
      simpl in H4...
      symmetry in H4.
      apply checkEncodeCasesD in H4...
      
      apply OLInPermutationL' in H4...
     apply OLInPermutation' in H6...
     rewrite H6, H4...
    + inversion H0... 
    ++ (* quantifier *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesU in H9...
      apply OLInPermutation' in H6...
      rewrite H6...
      rewrite Permutation_midle...
      apply LKAllR; intros...
       apply FocusingForallUP with (y:=x2) in H8...
       
      rewrite H6 in HisD'.
      rewrite <- Permutation_midle...
      eapply H with (m:=x3) (a:=a)...
       solveQF. 
        LLExact H10.
        rewrite <- H7...
       -
      apply PermSecond in H10.
      rewrite !secondApp in H10.
      rewrite !secCEncode in H10.
      simpl in H10...
      symmetry in H10.
      apply checkEncodeCasesU in H10...
      apply OLInPermutation' in H6...
      rewrite H6 in HisL'.
      rewrite H6...
      rewrite <- app_comm_cons.
      apply LKCtR.
      rewrite app_comm_cons.
      rewrite <- H6...
      
      apply LKAllR;intros...
      apply FocusingForallUP with (y:=x3) in H8...
      rewrite <- Permutation_midle.
      eapply H with (m:=x4) (a:=a)...
      solveQF.
      LLExact H11.
      simpl...
    ++ (* quantifier *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesD in H9...
      apply OLInPermutationL' in H6...
      rewrite H6...
      rewrite Permutation_midle...
       apply FocusingExistsDW in H8...
      apply LKAllL with (t:=x3)... 
      rewrite H6 in HisD.
      rewrite <- Permutation_midle...
      eapply H with (m:=x2) (a:=a)...
       solveQF. 
        LLExact H11.
        rewrite <- H7...
       -
      apply PermSecond in H10.
      rewrite !secondApp in H10.
      rewrite !secCEncode in H10.
      simpl in H10...
      symmetry in H10.
      apply checkEncodeCasesD in H10...
      apply OLInPermutationL' in H6...
      rewrite H6 in HisL.
      rewrite H6...
      rewrite <- app_comm_cons.
      apply LKCtL.
      rewrite app_comm_cons.
      rewrite <- H6...
      
      apply FocusingExistsDW in H8...
      
      apply LKAllL with (t:=x4);intros...
      rewrite <- Permutation_midle.
      eapply H with (m:=x3) (a:=a)...
      solveQF.
 ++ (* quantifier *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesU in H9...
      apply OLInPermutation' in H6...
      rewrite H6...
      rewrite Permutation_midle...
       apply FocusingExistsUP in H8...
      apply LKSomeR with (t:=x3); intros... 
      rewrite H6 in HisD'.
      rewrite <- Permutation_midle...
      eapply H with (m:=x2) (a:=a)...
       solveQF. 
        LLExact H11.
        rewrite <- H7...
       -
      apply PermSecond in H10.
      rewrite !secondApp in H10.
      rewrite !secCEncode in H10.
      simpl in H10...
      symmetry in H10.
      apply checkEncodeCasesU in H10...
      apply OLInPermutation' in H6...
      rewrite H6 in HisL'.
      rewrite H6...
      rewrite <- app_comm_cons.
      apply LKCtR.
      rewrite app_comm_cons.
      rewrite <- H6...
      
      apply FocusingExistsUP in H8...
      
      apply LKSomeR with (t:=x4);intros...
      rewrite <- Permutation_midle.
      eapply H with (m:=x3) (a:=a)...
      solveQF.
      
      LLExact H12.
      simpl...
       ++ (* quantifier *)
      apply BipoleReasoning in H3...
      -
      simpl in H8.
      apply checkEncodeCasesD in H9...
      apply OLInPermutationL' in H6...
      rewrite H6...
      rewrite Permutation_midle...
      apply LKSomeL; intros...
       apply FocusingForallDW with (y:=x2) in H8...
       
      rewrite H6 in HisD.
      rewrite <- Permutation_midle...
      eapply H with (m:=x3) (a:=a)...
       solveQF. 
        LLExact H10.
        rewrite <- H7...
       -
      apply PermSecond in H10.
      rewrite !secondApp in H10.
      rewrite !secCEncode in H10.
      simpl in H10...
      symmetry in H10.
      apply checkEncodeCasesD in H10...
      apply OLInPermutationL' in H6...
      rewrite H6 in HisL.
      rewrite H6...
      rewrite <- app_comm_cons.
      apply LKCtL.
      rewrite app_comm_cons.
      rewrite <- H6...
      
      apply LKSomeL;intros...
      apply FocusingForallDW with (y:=x3) in H8...
      rewrite <- Permutation_midle.
      eapply H with (m:=x4) (a:=a)...
      solveQF.
  + apply BipoleReasoning in H3...
     ++  
        apply FocusingQuest in H6...
        apply checkEncodeCasesD in H7... 
        apply OLInPermutationL' in H3...
        rewrite H3.
         rewrite <- perm_takeit_2...
       rewrite app_comm_cons.
        eapply H with (m:=x1) (a:=a)...
        LLExact H5.
    ++ 
      apply PermSecond in H8.
      rewrite !secondApp in H8.
      rewrite !secCEncode in H8.
      simpl in H8...
      symmetry in H8.
      apply checkEncodeCasesD in H8...
      apply OLInPermutationL' in H3...
      
      rewrite H3...
      rewrite <- app_comm_cons.
      apply LKCtL.
      rewrite app_comm_cons.
      rewrite <- H3...
        apply FocusingQuest in H6...
      rewrite app_comm_cons.
        eapply H with (m:=x3) (a:=a)...
  + apply BipoleReasoning in H3...
     ++  
        apply FocusingQuest in H6...
        apply checkEncodeCasesU in H7... 
        apply OLInPermutation' in H3...
        rewrite H3.
         rewrite <- perm_takeit_2...
       rewrite app_comm_cons.
        eapply H with (m:=x1) (a:=a)...
        LLExact H5. simpl...
    ++ 
      apply PermSecond in H8.
      rewrite !secondApp in H8.
      rewrite !secCEncode in H8.
      simpl in H8...
      symmetry in H8.
      apply checkEncodeCasesU in H8...
      apply OLInPermutation' in H3...
      
      rewrite H3...
      rewrite <- app_comm_cons.
      apply LKCtR.
      rewrite app_comm_cons.
      rewrite <- H3...
        apply FocusingQuest in H6...
      rewrite app_comm_cons.
        eapply H with (m:=x3) (a:=a)...
   
        LLExact H8. simpl...
    * solveSignature1.
Qed.
 
Theorem AdequacyLK:  forall a L L' D D', 
   isOLFormulaL L ->
   isOLFormulaL L' ->
   isOLFormulaL D ->
   isOLFormulaL D' ->
   mt a = true -> 
   (LKSeq (L ++ D) (L' ++ D') <->
          seq (LK a)
         (CEncode a (LEncode L) ++ CEncode a (REncode L'))
         (LEncode D ++ REncode D') (UP []) ).
Proof with sauto.
  intros.
  split;intros.
  + apply Soundeness'... 
  + apply seqtoSeqN in H4... 
    apply Completeness in H4...
Qed.

End LKAdequacy.


