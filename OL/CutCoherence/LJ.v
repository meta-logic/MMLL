(** * System LK for classical logic encoded as an LL theory

This file encodes the inference rules of the system LK. Since the
rules used are cut-coherent, the cut-elimination theorem applies for
this system.
 *)

Require Import MMLL.OL.CutCoherence.OLTactics.
Require Import MMLL.OL.CutCoherence.OLPosNeg.
Require Import MMLL.OL.CutCoherence.Bipoles.

Require Import Coq.Init.Nat.
Require Import MMLL.Misc.Permutations.

Export ListNotations.
Export LLNotations.
Set Implicit Arguments.

Section LJAdequacy.
Context {SI : Signature}.
Context {USI : UnbSignature}.
Context {USInoD : UnbNoDSignature}. 

(** ** Syntax *)
(** units: true and false *)
Inductive Constants := TT | FF  .
(** conjunction, disjunction and implication *)
Inductive Connectives := AND | OR | IMP  .
(** universal and existential quantifiers *)
Inductive Quantifiers := ALL|SOME .

Inductive UConnectives := .

Instance SimpleOLSig : OLSyntax:=
  {|
    OLType := nat;
    constants := Constants ;
    uconnectives := UConnectives;
    connectives := Connectives ;
    quantifiers := Quantifiers
  |}.


(**  Constants *)
Definition rulesCTE (c:constants) :=
  match c with
  | TT => ZEROTOP
  | FF => TOPZERO
  end.

(**  Binary connectives *)
Definition rulesBC (c :connectives) :=
  match c with
  | AND => PARTENSOR
  | OR =>  TENSORPAR
  | IMP => TENSORPAREXCH
  end.

(**  Unary connectives *)
Definition rulesUC (c :uconnectives) :=
  match c with
  | BOX => QUESTBANG
  end.
  
(**  Quantifiers *)
Definition rulesQD (q :quantifiers) :=
  match q with
  | ALL => ALLSOME
  | SOME => SOMEALL
  end
.

Instance SimpleOORUles : OORules :=
  {|
    rulesCte := rulesCTE ;
    rulesBin := rulesBC;
    rulesU := rulesUC;
    rulesQ := rulesQD
  |}.


(** An inductive definition for LJ. This will be used to prove that
the LL encoding is sound and complete *)

Inductive LJSeq : list uexp -> list uexp -> Prop :=
| LJTRUE : forall L L', LJSeq L ((t_cons TT)::L')
| LJFALSE : forall L L', LJSeq (t_cons FF :: L) L' 
| LJinit : forall L L' F,  LJSeq (F:: L) (F::L')

| LJAndL1 : forall L F G L', LJSeq (F :: L) L' -> LJSeq ( (t_bin AND F G) :: L) L'
| LJAndL2 : forall L F G L', LJSeq (G :: L) L' -> LJSeq ( (t_bin AND F G) :: L) L'
| LJAndR : forall L F G L', LJSeq L (F::L') -> LJSeq L (G::L') -> LJSeq L (t_bin AND F G :: L')

| LJOrL : forall L F G L',  LJSeq (F :: L) L' -> LJSeq (G :: L) L' -> LJSeq ( (t_bin OR F G) :: L) L'
| LJOrR1 : forall L F G L', LJSeq L (F::L') -> LJSeq L (t_bin OR F G :: L')
| LJOrR2 : forall L F G L', LJSeq L (G::L') -> LJSeq L (t_bin OR F G :: L')
                  
| LJAllL : forall L t FX L', uniform FX -> proper t -> LJSeq ( FX t :: L) L' -> LJSeq (t_quant ALL FX :: L) L'
| LJAllR : forall L FX L', uniform FX -> (forall x, proper x -> LJSeq L ((FX x)::L')) -> LJSeq L (t_quant ALL FX :: L')

| LJSomeL : forall L FX L', uniform FX -> (forall x, proper x -> LJSeq (FX x:: L) L') -> LJSeq (t_quant SOME FX :: L) L'
| LJSomeR : forall L FX t L', uniform FX -> proper t -> LJSeq L ((FX t)::L')-> LJSeq L (t_quant SOME FX::L')
(* Explicit exchange *)
| LJExL : forall L L' Delta, Permutation L L' -> LJSeq L Delta -> LJSeq L' Delta
| LJExR : forall L L' Delta, Permutation L L' -> LJSeq Delta L -> LJSeq Delta L'
(* Explicit contraction *)
| LJCtL : forall L L' F, LJSeq (F :: F :: L)  L' -> LJSeq (F :: L)  L'
| LJCtR : forall L L' F, LJSeq L (F :: F :: L')   -> LJSeq L (F :: L')

| LJWkL : forall L L' F, LJSeq L L' -> LJSeq (F :: L)  L'
| LJWkR : forall L L' F, LJSeq L L' -> LJSeq L (F :: L')

| LJImpL : forall F G L1 L2 L1' L2', LJSeq L1 (F::L1') -> LJSeq (G:: L2) L2' -> LJSeq (t_bin IMP F G ::L1++L2) (L1'++L2')
| LJImpR : forall L F G L', LJSeqT L L' [F] [G] ->  LJSeq L (t_bin IMP F G :: L')
    with
      LJSeqT : list uexp -> list uexp -> list uexp -> list uexp -> Prop :=
       | LJLift : forall L F L' D D' T, Remove F D D' -> LJSeqT D' T (F::L) L' ->  LJSeqT D T L L'                                  
       | LJRelease : forall L L' D T, LJSeq L L' -> LJSeqT D T L L'
.

Hint Constructors LJSeq : core .
Hint Constructors LJSeqT : core .

  Theorem LJSeqPerm1 D1  : forall D2 L R T,
  Permutation D1 D2 -> LJSeqT D2 T L R -> LJSeqT D1 T L R .
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent D1.
  induction Hseq;intros;eauto using Permutation_in.
  symmetry in Hp.
  generalize (Remove_Permutation_Ex2 H Hp);intros...
  eapply LJLift with (F:=F) (D':=x)...
  Qed.
  
  Theorem LJSeqPerm2 L1  : forall D L2 R T,
  Permutation L1 L2 -> LJSeqT D T L2 R -> LJSeqT D T L1 R .
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent L1.
  induction Hseq;intros;eauto using Permutation_in.
  apply LJRelease...
  eapply LJExL.
  exact (symmetry Hp).
  auto.
  Qed.

  Theorem LJSeqPerm3 R1  : forall D L R2 T,
  Permutation R1 R2 -> LJSeqT D T L R2 -> LJSeqT D T L R1.
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent R1.
  induction Hseq;intros;eauto using Permutation_in.
  apply LJRelease...
  eapply LJExR.
  exact (symmetry Hp).
  auto.
  Qed.
      
  Global Instance LJT_morph : 
  Proper ((@Permutation uexp) ==> eq ==> (@Permutation uexp) ==>  (@Permutation uexp)  ==> iff) (LJSeqT).
Proof.
  unfold Proper; unfold respectful. 
  intros.
  split;intros;subst.
  - symmetry in H.
    symmetry in H1.
    symmetry in H2.
    eapply LJSeqPerm1;eauto.
    eapply LJSeqPerm2;eauto.
    eapply LJSeqPerm3;eauto.
  - eapply LJSeqPerm1;eauto.
    eapply LJSeqPerm2;eauto.
    eapply LJSeqPerm3;eauto.
Qed.

  Global Instance LJ_morph : 
  Proper ((@Permutation uexp) ==> (@Permutation uexp) ==> iff) (LJSeq).
Proof.
  unfold Proper; unfold respectful. 
  intros.
  split;intros;subst.
  - eauto. 
  - symmetry in H. 
    symmetry in H0.
    eauto. 
Qed.

  Theorem LJSeqTWkL D : forall F L R T, LJSeqT D T L R -> LJSeqT D T (F::L) R .
  Proof with  CleanContext.
   intros.
   induction H;intros...
     apply Remove_Permute in H...
     rewrite H.
     apply LJLift with (F:=F0) (D':=D')...
     eapply LJSeqPerm2.
     2:{ exact IHLJSeqT. }
     perm.
 Qed.      
 
  Theorem LJSeqTWkR D : forall F L R T, LJSeqT D T L R -> LJSeqT D T L (F::R) .
  Proof with  CleanContext.
   intros.
   induction H;intros...
     apply Remove_Permute in H...
     rewrite H.
     apply LJLift with (F:=F0) (D':=D')...
 Qed.
   
 Theorem ImpGenInv D L R T : 
    LJSeqT D T L R ->  
    exists A B, Permutation D (A++B) /\ LJSeq (L++A) R.
  Proof with  CleanContext.
   intros.
   induction H;intros...
   - apply Remove_Permute in H...
     exists (F::x).
     exists x0.
     split...
     eapply LJExL.
     2:{ exact H3. }
     perm.
   - exists [].
     exists D.
     split...
 Qed.    
   
 
 Theorem ImpGen D : forall A B L R T , 
    Permutation D (A++B) -> LJSeq (L++A) R ->
    LJSeqT D T L R.  
  Proof with  CleanContext.
   induction D;intros...
   checkPermutationCases H. 
     + inversion H0...
       - apply ListConsApp'' in H3...
         checkPermutationCases H1.
         { eapply LJLift with  (D':=D)... }
         { eapply LJLift with  (D':=D)...
           eapply IHD with (A:=x) (B:=B)...
           eapply LJExL.
           2:{ exact H0. }
           rewrite H3.
           rewrite H1... }
      - apply ListConsApp'' in H3...
         checkPermutationCases H1.
         { eapply LJLift with  (D':=D)... }
         { eapply LJLift with  (D':=D)...
           eapply IHD with (A:=x) (B:=B)...
           eapply LJExL.
           2:{ exact H0. }
           rewrite H3.
           rewrite H1... }
      - apply ListConsApp'' in H...
         checkPermutationCases H1.
         { eapply LJLift with  (D':=D)...
            eapply IHD with (A:=x) (B:=B)...
            apply LJAndL1.
            eapply LJExL.
           2:{ exact H3. }
           rewrite H5... }
         { eapply LJLift with  (D':=D)...
           eapply IHD with (A:=x) (B:=B)...
           eapply LJExL.
           2:{ exact H0. }
           rewrite H1.
           rewrite H4... }
         eapply LJLift with  (D':=D)...
         eapply IHD with (A:=x) (B:=B)...
         rewrite perm_swap.
         apply LJAndL1. 
         eapply LJExL.
         2:{ exact H3. }
         rewrite H1...
      - apply ListConsApp'' in H...
         checkPermutationCases H1.
         { eapply LJLift with  (D':=D)...
            eapply IHD with (A:=x) (B:=B)...
            apply LJAndL2.
            eapply LJExL.
           2:{ exact H3. }
           rewrite H5... }
         { eapply LJLift with  (D':=D)...
           eapply IHD with (A:=x) (B:=B)...
           eapply LJExL.
           2:{ exact H0. }
           rewrite H1.
           rewrite H4... }
         eapply LJLift with  (D':=D)...
         eapply IHD with (A:=x) (B:=B)...
         rewrite perm_swap.
         apply LJAndL2. 
         eapply LJExL.
         2:{ exact H3. }
         rewrite H1...
      - eapply LJLift with  (D':=D)...
        eapply IHD with (A:=x) (B:=B)...
        apply LJAndR.
        eapply LJExL.
        2:{ exact H. }
        rewrite H1...
        eapply LJExL.
        2:{ exact H3. }
        rewrite H1...
      - apply ListConsApp'' in H...
        checkPermutationCases H1.  
        { eapply LJLift with  (D':=D)...
            eapply IHD with (A:=x) (B:=B)...
            apply LJOrL. 
            eapply LJExL.
           2:{ exact H3. }
           rewrite H6... 
            eapply LJExL.
           2:{ exact H4. }
           rewrite H6... 
        }
         { eapply LJLift with  (D':=D)...
           eapply IHD with (A:=x) (B:=B)...
           rewrite H1.
           rewrite perm_swap.
           apply LJOrL. 
           eapply LJExL.
           2:{ exact H3. }
           rewrite H5...
           eapply LJExL.
           2:{ exact H4. }
           rewrite H5... }
         { eapply LJLift with  (D':=D)...
           eapply IHD with (A:=x) (B:=B)...
           rewrite perm_swap.
           apply LJOrL. 
           eapply LJExL.
           2:{ exact H3. }
           rewrite H1...
           eapply LJExL.
           2:{ exact H4. }
           rewrite H1... }
      -  eapply LJLift with  (D':=D)...
         eapply IHD with (A:=x) (B:=B)...
         apply LJOrR1. 
         eapply LJExL.
           2:{ exact H. }
           rewrite H1... 
      -  eapply LJLift with  (D':=D)...
         eapply IHD with (A:=x) (B:=B)...
         apply LJOrR2. 
         eapply LJExL.
           2:{ exact H. }
           rewrite H1...
      - apply ListConsApp'' in H...
        checkPermutationCases H1.  
        { eapply LJLift with  (D':=D)...
            eapply IHD with (A:=x) (B:=B)...
            apply LJAllL with (t:=t)... 
            eapply LJExL.
           2:{ exact H5. }
           rewrite H7... }
        { eapply LJLift with  (D':=D)...
           eapply IHD with (A:=x) (B:=B)...
           rewrite H1.
           rewrite perm_swap.
          apply LJAllL with (t:=t)... 
           eapply LJExL.
           2:{ exact H5. }
           rewrite H6... }
         eapply LJLift with  (D':=D)...
         eapply IHD with (A:=x) (B:=B)...
         rewrite perm_swap.
          apply LJAllL with (t:=t)... 
         eapply LJExL.
         2:{ exact H5. }
         rewrite H1...
      - eapply LJLift with  (D':=D)...
        eapply IHD with (A:=x) (B:=B)...
        apply LJAllR;intros... 
        apply H3 in H4.
        eapply LJExL.
        2:{ exact H4. }
           rewrite H1... 
     - apply ListConsApp'' in H...
        checkPermutationCases H1.  
        { eapply LJLift with  (D':=D)...
            eapply IHD with (A:=x) (B:=B)...
            apply LJSomeL;intros... 
            apply H4 in H. 
            eapply LJExL.
           2:{ exact H. }
           rewrite H6... }
        { eapply LJLift with  (D':=D)...
           eapply IHD with (A:=x) (B:=B)...
           rewrite H1.
           rewrite perm_swap.
          apply LJSomeL;intros... 
            apply H4 in H. 
           eapply LJExL.
           2:{ exact H. }
           rewrite H5... }
         eapply LJLift with  (D':=D)...
         eapply IHD with (A:=x) (B:=B)...
         rewrite perm_swap.
          apply LJSomeL;intros... 
            apply H4 in H. 
         eapply LJExL.
         2:{ exact H. }
         rewrite H1...
      - eapply LJLift with  (D':=D)...
        eapply IHD with (A:=x) (B:=B)...
        apply LJSomeR with (t:=t)...  
        eapply LJExL.
        2:{ exact H4. }
           rewrite H1...
      -  eapply LJLift with  (D':=D)...
         eapply IHD with (A:=x) (B:=B)...
         eapply LJExL.
         2:{ exact H3.  }
         rewrite H.
         rewrite H1...
       - eapply LJLift with  (D':=D)...
         eapply IHD with (A:=x) (B:=B)...
         rewrite <- H.
         eapply LJExL.
         2:{ exact H3.  }
         rewrite H1...
      - apply ListConsApp'' in H...
         checkPermutationCases H1.
         { eapply LJLift with  (D':=D)...
           eapply IHD with (A:=x) (B:=B)...
           apply LJCtL.
           eapply LJExL.
           2:{ exact H3. }
           rewrite H5... }
         { eapply LJLift with  (D':=D)...
           eapply IHD with (A:=x) (B:=B)...
           rewrite H1.
           rewrite perm_swap.
           apply LJCtL.
           eapply LJExL.
           2:{ exact H3. }
           rewrite H4... }
         eapply LJLift with  (D':=D)...
         eapply IHD with (A:=x) (B:=B)...
         rewrite perm_swap.
         apply LJCtL.
         eapply LJExL.
         2:{ exact H3. }
         rewrite H1...
      -  eapply LJLift with  (D':=D)...
         eapply IHD with (A:=x) (B:=B)...
         apply LJCtR.
         eapply LJExL.
         2:{ exact H. }
         rewrite H1...
      - apply ListConsApp'' in H...
         checkPermutationCases H1.
         { eapply LJLift with  (D':=D)...
           eapply IHD with (A:=x) (B:=B)...
           apply LJWkL.
           rewrite <- H5... }
         { eapply LJLift with  (D':=D)...
           eapply IHD with (A:=x) (B:=B)...
           rewrite H1.
           rewrite perm_swap.
           apply LJWkL.
           rewrite <- H4... }
         eapply LJLift with  (D':=D)...
         eapply IHD with (A:=x) (B:=B)...
         rewrite perm_swap.
         apply LJWkL.
         eapply LJExL.
         2:{ exact H3. }
         rewrite H1... 
      -  eapply LJLift with  (D':=D)...
         eapply IHD with (A:=x) (B:=B)...
         apply LJWkR.
         eapply LJExL.
         2:{ exact H. }
         rewrite H1...
      - apply ListConsApp'' in H...
         checkPermutationCases H1.
         { eapply LJLift with  (D':=D)...
           eapply IHD with (A:=x) (B:=B)...
           rewrite <- H6.
           eapply LJImpL... }
         { eapply LJLift with  (D':=D)...
           eapply IHD with (A:=x) (B:=B)...
           rewrite H1.
           rewrite perm_swap.
           rewrite <- H5.
            eapply LJImpL... }
         eapply LJLift with  (D':=D)...
         eapply IHD with (A:=x) (B:=B)...
          assert(Permutation (a :: t_bin IMP F G :: x0 ++ x) (t_bin IMP F G :: x0 ++ (a::x))) by perm.
          rewrite H.
          rewrite <- H1. 
          rewrite <- H6.
            eapply LJImpL...
      -  eapply LJLift with  (D':=D)...
         eapply IHD with (A:=x) (B:=B)...
         apply LJImpR.
         eapply LJSeqPerm1.
         2:{ exact H.  }
         rewrite H1...
      + apply LJLift with (F:=a) (D':=D)...
        eapply IHD with (A:=A) (B:=x)...
    Qed.  
  
  
Theorem LJCtLGen C : forall L L', LJSeq (C ++ C ++ L)  L' -> LJSeq (C ++ L) L'.
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply LJCtL.
  rewrite Permutation_cons_append.
  rewrite Permutation_cons_append.
  do 2 rewrite app_assoc_reverse.
  eapply IHC.
  assert(Hs: Permutation (C ++ C ++ L ++ [a] ++ [a]) ((a :: C) ++ (a :: C) ++ L)) by perm.
  rewrite Hs...
Qed.


Theorem LJCtRGen C : forall L L', LJSeq L (C ++ C ++ L') -> LJSeq L (C ++ L').
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply LJCtR.
  rewrite Permutation_cons_append.
  rewrite Permutation_cons_append.
  do 2 rewrite app_assoc_reverse.
  eapply IHC.
  assert(Hs: Permutation (C ++ C ++ L' ++ [a] ++ [a]) ((a :: C) ++ (a :: C) ++ L')) by perm.
  rewrite Hs...
Qed.

Theorem LJWkLGen C : forall L L', LJSeq L  L' -> LJSeq (C ++ L) L'.
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply LJWkL...
Qed.

Theorem LJWkRGen C : forall L L', LJSeq L  L' -> LJSeq L (C++L').
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply LJWkR...
Qed.


Theorem SoundenessLJT j L L' D D'
     (Mj: mt j = true) (Fj: m4 j = true)
     (isFL: isOLFormulaL L) (isFL': isOLFormulaL L')
     (isFD: isOLFormulaL D) (isFD': isOLFormulaL D') : 
     forall  (Hyp: LJSeqT D D' L L') , 
     tri_bangK4' (OLTheoryI (i:=j) (a:=j)) (CEncode j (LEncode D)) 
                j (CEncode j (LEncode L) ++ CEncode loc (REncode L')) [] (> []) with
     SoundenessLJ j L L'
     (Mj: mt j = true) (Fj: m4 j = true)
     (isFL: isOLFormulaL L) (isFL': isOLFormulaL L')  : 
     forall (Hyp: LJSeq L L') , seq (OLTheoryI (i:=j) (a:=j)) (CEncode j (LEncode L) ++ CEncode loc (REncode L')) [] (> []).
Proof with CleanContext;SLSolve;OLSolve.

* intros. 
  induction Hyp.
  +  apply Remove_Permute in H...
    eapply exchangeCCK4 with (CC:=(CEncode j (LEncode (F :: D')))).
    apply CEncodePerm .
   
    apply Permutation_map;auto.

    simpl.
    copyK4 j (d| F |) (CEncode j (LEncode D')).
     
    assert(Hs:tri_bangK4' (OLTheoryI (i:=j) (a:=j)) (CEncode j (LEncode D')) j
          (CEncode j (LEncode (F :: L)) ++ CEncode loc (REncode L')) []
          (> [])).
    rewrite H in isFD.
    apply IHHyp...       
    eapply exchangeCCKK4.
    2:{ exact Hs. }
    CleanContext.
    rewrite plustpropT...
  + eapply SoundenessLJ with (j:=j)  in H...
    finishExp...
* intros. 
  induction Hyp.
    + (* True on the right *)
    decide3 (makeRuleConstant TT Right)...
    constructor;constructor;auto.
    tensorUnb...
   + (* false on the left *)
    decide3 (makeRuleConstant FF Left)...
    constructor;constructor;auto.
    tensorUnb...
   + (* init *)
    decide3 (RINIT F)...
    apply ooth_initI... 
    tensorUnb...
  + (* ANDL1 *)
    decide3 (makeRuleBinI (i:=j) AND Left F G)...
    apply ooth_rulesI...
    constructor...
    tensorUnb...
    oplus1. 
    rewrite <- (app_nil_l [d| F |]).
    change [d| F |] with ( LEncode [F]). 
    eapply PosSetP...
    inversion isFL...
    inversion H1...
    LLSwap.
    apply weakening...
 + (* ANDL2 *)
    decide3 (makeRuleBinI (i:=j) AND Left F G)...
    apply ooth_rulesI...
    constructor...
    tensorUnb...
    
    oplus2.
    rewrite <- (app_nil_l [d| G |]).
    change [d| G |] with ( LEncode [G]). 
    eapply PosSetP...
    inversion isFL...
    inversion H1...
    LLSwap.
    apply weakening...
  + (* And R *)
    decide3 (makeRuleBinI (i:=j) AND Right F G)...
    apply ooth_rulesI...
    constructor...
    tensorUnb...
    PosNeg loc...
    inversion isFL'...
    inversion H1...
    LLPerm((loc, u| t_bin AND F G |) :: CEncode j (LEncode L) ++ (loc, u| F |) :: CEncode loc (REncode L')).
    apply weakening...
    PosNeg loc...
    inversion isFL'...
    inversion H1...
    LLPerm((loc, u| t_bin AND F G |) :: CEncode j (LEncode L) ++ (loc, u| G |) :: CEncode loc (REncode L')).
    apply weakening...
  + (* Or L *)
    decide3 (makeRuleBinI (i:=j) OR Left F G)...
    apply ooth_rulesI...
    constructor...
    tensorUnb...
    PosNeg j... 
    
    LLPerm((j, d| t_bin OR F G |) :: (j, d| F |) :: CEncode j (LEncode L) ++  CEncode loc (REncode L')).
    apply weakening...
    apply IHHyp1...
    
    PosNeg j... 
    
    LLPerm((j, d| t_bin OR F G |) :: (j, d| G |) :: CEncode j (LEncode L) ++  CEncode loc (REncode L')).
    apply weakening...
    apply IHHyp2...
   + (* ORRL1 *)
    decide3 (makeRuleBinI (i:=j) OR Right F G)...
    apply ooth_rulesI...
    constructor...
    tensorUnb...
    
    oplus1.
    PosNeg loc...
    LLPerm((loc, u| t_bin OR F G |) :: CEncode j (LEncode L) ++ (loc, u| F |) ::  CEncode loc (REncode L')).
    apply weakening...
    apply IHHyp...
   + (* ORRL2 *)
    decide3 (makeRuleBinI (i:=j) OR Right F G)...
    apply ooth_rulesI...
    constructor...
    tensorUnb...
    
    oplus2.
    PosNeg loc...
    LLPerm((loc, u| t_bin OR F G |) :: CEncode j (LEncode L) ++ (loc, u| G |) ::  CEncode loc (REncode L')).
    apply weakening...
    apply IHHyp...
  + (* forall left *)
    decide3 (makeRuleQ ALL Left FX)...
    constructor;constructor;auto...
    tensorUnb...
    existential t...
    PosNeg j...
    LLPerm ((j, d| t_quant ALL FX |)::(j, d| FX t |)::CEncode j (LEncode L) ++ CEncode loc (REncode L')).
    apply weakening...
    apply IHHyp...
  + (* forall right *)
    decide3 (makeRuleQ ALL Right FX)...
    constructor;constructor;auto...
    tensorUnb...
    PosNeg loc...
    LLPerm ((loc, u| t_quant ALL FX |)::CEncode j (LEncode L) ++ (loc, u| FX x |)::CEncode loc (REncode L')).
    apply weakening...
    apply H1... 
  + (* existst left *)
    decide3 (makeRuleQ SOME Left FX)...
    constructor;constructor;auto...
    tensorUnb...
    PosNeg j...
    LLPerm ((j, d| t_quant SOME FX |)::(j, d| FX x |)::CEncode j (LEncode L) ++ CEncode loc (REncode L')).
    apply weakening...
    apply H1... 
  + (* exists right *)
    decide3 (makeRuleQ SOME Right FX)...
    constructor;constructor;auto...
    tensorUnb...
   
    existential t.
    PosNeg loc...
    LLPerm ((loc, u| t_quant SOME FX |)::CEncode j (LEncode L) ++ (loc, u| FX t |)::CEncode loc (REncode L')).
    apply weakening...
    apply IHHyp...
  + (* exchange *)
    assert(Hs: Permutation (LEncode L) (LEncode L')).
    eapply Permutation_map;auto.
    apply CEncodePerm with (i:=j) in Hs. 
    rewrite <- Hs...
    apply IHHyp...
  + 
    assert(Hs: Permutation (REncode L) (REncode L')).
    eapply Permutation_map;auto.
    apply CEncodePerm with (i:=loc) in Hs. 
    rewrite <- Hs...
    apply IHHyp...
  + (* contraction *)
    simpl.
    eapply @contraction with (F:=(j, d| F |))...
    apply IHHyp... OLSolve.
  + simpl.
    LLPerm((loc, u| F |) ::  CEncode j (LEncode L) ++ CEncode loc (REncode L')).
    eapply @contraction with (F:=(loc, u| F |))...
    LLPerm(CEncode j (LEncode L) ++ (loc, u| F |) :: (loc, u| F |) :: CEncode loc (REncode L')).
    apply IHHyp... OLSolve.
  + (* weakening *)
    simpl.
    apply weakening...
    apply IHHyp...
   + (* weakening *)
    simpl.
    LLPerm((loc, u| F |) ::  CEncode j (LEncode L) ++ CEncode loc (REncode L')).
    apply weakening...
    apply IHHyp...
  + (* implication left *)
    decide3 (makeRuleBinI (i:=j) IMP Left F G)...
    apply ooth_rulesI...
    constructor...
    tensorUnb...
    apply weakening...
    tensorUnb...
    PosNeg loc...
    rewrite !REncodeApp.
    rewrite !LEncodeApp.
    rewrite !CEncodeApp.
    LLPerm (((CEncode j (LEncode L2) ++ CEncode loc (REncode L2')) ++
    CEncode j (LEncode L1) ++ (loc, u| F |)::CEncode loc (REncode L1'))).
    apply weakeningGen...
    apply IHHyp1...
    inversion isFL...
    PosNeg j...
    rewrite !REncodeApp.
    rewrite !LEncodeApp.
    rewrite !CEncodeApp.
    LLPerm (((CEncode j (LEncode L1) ++ CEncode loc (REncode L1')) ++
    (j, d| G |):: CEncode j (LEncode L2) ++ CEncode loc (REncode L2'))).
    apply weakeningGen...
    apply IHHyp2...
    inversion isFL...
  + (* implication right *)
   decide3 (makeRuleBinI (i:=j) IMP Right F G)...
    apply ooth_rulesI...
    constructor...
    tensorUnb...
    apply SoundenessLJT with (j:=j) in H...
    apply InvSubExpPhaseUK4' in H... 
    rewrite SetTPlusT in H5...
    LLPerm((CEncode j (LEncode L) ++ CEncode loc (REncode L'))++[ (loc, u| t_bin IMP F G |)]).
   apply weakeness_mutual'... 
   
   apply destructCEncode in H0...
   apply CEncodePerm with (i:=j) in H7.
   rewrite H7.
   rewrite CEncodeApp.
   rewrite <- H0.
   rewrite <- H6.
   eapply @GenK4Rel' with (C4:=x) (CK:=[]) (CN:=CEncode loc (REncode L')++x0)...
   rewrite SetTPlusT...
   solveLL.     
   PosNeg loc...
   PosNeg j...     
Qed.


 (** Completeness theorem *)
Theorem Completeness: forall n j L L' D D', 
    m4 j = true -> mt j = true ->
    isOLFormulaL L ->
    isOLFormulaL L' ->
    isOLFormulaL D ->
    isOLFormulaL D' ->
    seqN (OLTheoryI (i:=j) (a:=j)) n (CEncode j (LEncode L) ++ CEncode loc (REncode L')) (LEncode D ++  REncode D') (> []) ->
    LJSeq (L++D) (L'++D') .
Proof with CleanContext;SLSolve;OLSolve.
  intro.
  induction n using strongind; intros j L L' D D' Fj Mj  HisL HisL' HisD HisD' Hseq; 
  inversion Hseq...
  * apply RemoveNotPos1 in H2;sauto...
    OLSolve. OLSolve.
  * apply InUNotPos in H4;sauto...
    sfold. rewrite secCEncode.
    OLSolve.
    sfold. rewrite secCEncode.
    OLSolve.
  * apply RemoveNotPos2 in H4;sauto...
    sfold. rewrite secCEncode. 
    OLSolve.
    sfold. rewrite secCEncode. 
    OLSolve.
  * inversion H1...
  + inversion H0...
  ++ (* Constant right *)
      apply FocusingRightCteU in H3...
      -
      apply checkEncodeCasesU in H7... 
      (* by cases on C *)
      destruct C...
      apply OLInPermutation' in H5...
      rewrite H5...
      rewrite <- perm_takeit_2...
      inversion H8...
      - destruct C.
        rewrite !secCEncode in H7.
        apply upRight in H7.
        apply OLInPermutation in H7...
        rewrite H3...
        inversion H8...
    ++ (* constant left *)
      apply FocusingLeftCteU in H3...
      -
      apply checkEncodeCasesD in H7... 
      destruct C...
      inversion H8...
      apply OLInPermutationL' in H5...
      rewrite H5...
      rewrite <- perm_takeit_2...
      - destruct C.
       inversion H8...
        rewrite !secCEncode in H7.
        apply downLeft in H7.
        apply OLInPermutationL in H7...
        rewrite H3...
  + inversion H5... 
    ++ (* binary connective right *)
      apply FocusingRightIRuleU in H3...
      -
      apply checkEncodeCasesU in H9...
       (* by cases on C *)
      destruct C...
      { apply AppPARTENSORRightI in H10...
        apply OLInPermutation' in H7...
        rewrite H7 in HisD'.
        rewrite H7...
        rewrite <- perm_takeit_2...
        apply LJAndR...
        
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x2)...
        LLExact H11.
        rewrite <- H8...
        
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x2)...
        LLExact H12.
        rewrite <- H8...
      }  
      { (*  OR *)
        apply AppTENSORPARRightI in H10...
        apply OLInPermutation' in H7...
        rewrite H7 in HisD'.
        rewrite H7...
        rewrite <- perm_takeit_2...  
        apply LJOrR1...
        
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x2)...
        LLExact H10.
        rewrite <- H8...
        
        apply OLInPermutation' in H7...
        rewrite H7 in HisD'.
        rewrite H7...
        rewrite <- perm_takeit_2...  
        apply LJOrR2...
        
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x2)...
        LLExact H10.
        rewrite <- H8...
      }
      { (* impl *)
        apply AppTENSORPAREXCHRightI in H10...
        apply OLInPermutation' in H7...
        rewrite H7 in HisD'.
        rewrite H7...
        rewrite <- perm_takeit_2...
        apply map_eq_nil in H3.
        apply map_eq_nil in H8...
          
        apply destructEncode2 in H10...
        rewrite H7 in H15.
        rewrite H7 in H13...
        assert(SetK4 j (CEncode loc x1))...
        apply setK4CEncode in H3...
        apply destructLEncode in H8...
        rewrite H17 in HisL.
        apply LJImpR... 
        eapply ImpGen with (A:=x1) (B:=x7)...
        rewrite Permutation_cons_append...
        change [G] with ([]++[G]).
        
        eapply H with (j:=j) (m:=x2)...
        LLExact H15.
        srewrite H8...
      }
      
      - destruct C...
      { apply AppPARTENSORRightI in H10...
        rewrite !secCEncode in H9.
        apply upRight in H9.
        apply OLInPermutation in H9...
        rewrite H3...
        apply LJCtR.
        apply LJAndR.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x0)...
        LLExact H10.
        
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x0)...
        LLExact H11.
      }
      { rewrite !secCEncode in H9.
        apply upRight in H9.
        apply OLInPermutation in H9...
        
        apply AppTENSORPARRightI in H10...
        
        rewrite H3...
        apply LJCtR.
        apply LJOrR1.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x1)...
        LLExact H9.
        
        rewrite H3...
        apply LJCtR.
        apply LJOrR2.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x1)...
        LLExact H9.
     }
     {  rewrite !secCEncode in H9.
        apply upRight in H9.
        apply OLInPermutation in H9...
       
        apply AppTENSORPAREXCHRightI in H10...
        rewrite H3...
        apply map_eq_nil in H7.
        apply map_eq_nil in H11...
          
        apply destructEncode2 in H9...
        rewrite H9 in H14.
        rewrite H9 in H12...
        assert(SetK4 j (CEncode loc x5))...
        apply setK4CEncode in H7...
        apply destructLEncode in H11...
        rewrite H18 in HisL.
        apply LJImpR... 
        eapply ImpGen with (A:=x5) (B:=x8)...
        rewrite Permutation_cons_append...
        change [G] with ([]++[G]).
        
        eapply H with (j:=j) (m:=x1)...
        LLExact H14.
        srewrite H11...
       }
    ++ (* binary connective left *)
      apply FocusingLeftIRuleU in H3...
      -
      apply checkEncodeCasesD in H9...
       (* by cases on C *)
      destruct C...
      { apply AppPARTENSORLeftI in H10...
        apply OLInPermutationL' in H7...
        rewrite H7 in HisD.
        rewrite H7...
        rewrite <- perm_takeit_2...
        apply LJAndL1...
        
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x2)...
        LLExact H10.
        
        apply OLInPermutationL' in H7...
        rewrite H7 in HisD.
        rewrite H7...
        rewrite <- perm_takeit_2...
        apply LJAndL2...
        
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x2)...
        LLExact H10.
      }  
      { (*  OR *)
        apply OLInPermutationL' in H7...
        rewrite H7 in HisD.
        rewrite H7...
        rewrite <- perm_takeit_2...
        
        apply AppTENSORPARLeftI in H10... 
          
        apply LJOrL...
        
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x2)...
        LLExact H11.
        
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x2)...
        LLExact H12.
      }
      { (* impl *)
        apply OLInPermutationL' in H7...
        rewrite H7 in HisD.
        apply LJCtLGen.
        apply LJCtRGen.
        rewrite H7...
        rewrite <- perm_takeit_2...
        rewrite <- perm_takeit_2...
          
        apply AppTENSORPAREXCHLeftI in H10...   
        rewrite H11 in H8.
        apply destructEncode in H8...
        rewrite H15.
        rewrite H9.
        assert(Hs1:Permutation (t_bin IMP F0 G :: L ++ L ++ x ++ x6) 
              (t_bin IMP F0 G :: (L ++ x) ++ (L++x6))) by perm.
              
        assert(Hs2:Permutation (L' ++ L' ++ x5 ++ x7) ((L' ++ x5) ++ (L'++x7))) by perm.
        
        rewrite Hs1. rewrite Hs2.
        apply LJImpL...
        rewrite Permutation_cons_append.
        rewrite app_assoc_reverse.
        eapply H with (j:=j) (m:=x2)...
        assert(isOLFormulaL x1)...
        OLSolve.
        LLExact H10.
        rewrite REncodeApp.
        rewrite H8...
        rewrite Permutation_cons_append.
        rewrite app_assoc_reverse.
        eapply H with (j:=j) (m:=x2)...
        assert(isOLFormulaL x1)...
        LLExact H13.
        rewrite LEncodeApp.
        rewrite H12...
      }
      - destruct C...
      { rewrite !secCEncode in H9.
        apply downLeft in H9.
        apply OLInPermutationL in H9...
        rewrite H3...
        apply AppPARTENSORLeftI in H10...
        
        apply LJCtL.
        apply LJAndL1.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x1)...
        
        apply LJCtL.
        apply LJAndL2.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x1)...
      }
      { rewrite !secCEncode in H9.
        apply downLeft in H9.
        apply OLInPermutationL in H9...
        
        rewrite H3...
        apply AppTENSORPARLeftI in H10...
       
        apply LJCtL.
        apply LJOrL.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x1)...
     
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x1)...
     }
     {  rewrite !secCEncode in H9.
        apply downLeft in H9.
        apply OLInPermutationL in H9...
        
        apply LJCtLGen.
        apply LJCtLGen.
        apply LJCtRGen.
        
        
        apply AppTENSORPAREXCHLeftI in H10...
        apply destructEncode in H10...
        rewrite H10.
        rewrite H14.
       
        rewrite H3...
        rewrite perm_takeit_2. 
        apply LJWkLGen.
        
        assert(Hs1:Permutation (t_bin IMP F0 G :: t_bin IMP F0 G :: x0 ++ t_bin IMP F0 G :: x0 ++ x ++ x5) 
                           (t_bin IMP F0 G :: ((t_bin IMP F0 G :: x0) ++ x) ++  ((t_bin IMP F0 G :: x0)) ++ x5)) by perm.
        assert(Hs2:Permutation (L' ++ L' ++ x4 ++ x6) 
                               ((L' ++ x4) ++ (L'++x6))) by perm.
       rewrite Hs1.
        rewrite Hs2.
       clear Hs1 Hs2. 
        rewrite <- H3.
        apply LJImpL.
       
        rewrite perm_takeit_2. 
        eapply H with (j:=j) (m:=x1)...
        LLExact H9.
        rewrite H8...
        
        rewrite perm_takeit_2. 
        eapply H with (j:=j) (m:=x1)...
        LLExact H12.
       }
  +  apply FocusingInitRuleU in H3;sauto.
    ++   
      apply destructEncode in H4...
      elim NoDinR with (F:=OO) (L0:=x2).
      rewrite H9...
      elim NoDinR with (F:=OO) (L0:=x2).
      rewrite H9...
       
      assert(REncode x0 = REncode [ OO ]) by auto.
      assert(LEncode x1 = LEncode [ OO ]) by auto.
      apply MapREncodeEqual in H3.
      apply MapLEncodeEqual in H4.
      rewrite H3 in H8.
      rewrite H4 in H5.
      rewrite H5. rewrite H8.
      apply LJWkLGen.
      apply LJWkLGen.
      apply LJWkRGen...
      
      elim NoUinL with (F:=OO) (L0:=x).
      rewrite H6...
   ++  CleanContext.
        rewrite !setUtoGetU in H6...
        rewrite !secCEncode in H6...
        apply downLeft in H6.
        apply OLInPermutationL in H6...
        assert(REncode D' = REncode [ OO ]) by auto.
        apply MapREncodeEqual in H4.
        rewrite H4.
        rewrite H3.
        apply LJWkRGen...
    ++ elim NoUinL with (F:=OO) (L0:=D).
       rewrite H5...
    ++ elim NoDinR with (F:=OO) (L0:=D').
       rewrite H7...
    ++  CleanContext. 
        rewrite !setUtoGetU in H6...
        rewrite !secCEncode in H6...
        apply upRight in H6.
        apply OLInPermutation in H6...
        assert(LEncode D = LEncode [ OO ]) by auto.
        apply MapLEncodeEqual in H5.
        rewrite H5.
        rewrite H3.
        apply LJWkLGen...
    ++  CleanContext. 
        rewrite !setUtoGetU in H6...
        rewrite !secCEncode in H6...
        apply upRight in H6.
        apply OLInPermutation in H6...
        
        CleanContext. 
        rewrite !setUtoGetU in H5...
        rewrite !secCEncode in H5...
         apply downLeft in H5.
        apply OLInPermutationL in H5...
      
        rewrite H4.
        rewrite H3...
  + inversion H0... 
    ++ (* quantifier *)
      apply FocusingRightQU in H3...
      -
      apply checkEncodeCasesU in H8...
      (* by cases on C *)
      destruct C...
      { (* All *)
        apply AppALLSOMERight in H9...
        apply OLInPermutation' in H6...
        rewrite H6 in HisD'.
        rewrite H6...
        
        rewrite <- perm_takeit_2...
        apply LJAllR;intros...
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:= x2)...
        apply H9 in H3.
        LLExact H3.
        rewrite <- H7...
      }
      { (* Exists *)
        apply AppSOMEALLRight in H9...
        apply OLInPermutation' in H6...
        rewrite H6 in HisD'.
        rewrite H6...
        
        rewrite <- perm_takeit_2...
        eapply LJSomeR;eauto.
        rewrite perm_takeit_2...
        apply H with (j:=j) (m:= x2)...
        LLExact H11.
        rewrite <- H7...
      }
    - destruct C...
      { CleanContext. 
        rewrite !secCEncode in H8...
        apply upRight in H8.
        apply OLInPermutation in H8...
        
        apply LJCtRGen.
        rewrite H3...
        rewrite perm_takeit_2...
        apply LJWkRGen.
        rewrite app_comm_cons.
        rewrite <- H3. 
        apply AppALLSOMERight in H9...
        
        apply LJAllR;auto;intros.
        
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x1)...
        apply H8 in H6.
        LLExact H6.  }
      { rewrite !secCEncode in H8.
        apply upRight in H8.
        apply OLInPermutation in H8...
        
        apply LJCtRGen.
        rewrite H3...
        rewrite perm_takeit_2...
        apply LJWkRGen.
        rewrite app_comm_cons.
        rewrite <- H3. 
        apply AppSOMEALLRight in H9...
        
        
        apply LJSomeR with (t:=x2)... 
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x1)...
        LLExact H10.  }
    ++ (* quantifier *)
      apply FocusingLeftQU in H3...
      -
      apply checkEncodeCasesD in H8...
      (* by cases on C *)
      destruct C...
      { (* All *)
        apply OLInPermutationL' in H6...
        rewrite H6 in HisD.
        rewrite H6...
        
         apply AppALLSOMELeft in H9...
       
        rewrite <- perm_takeit_2...
        apply LJAllL with (t:=x3)... 
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:= x2)...
        LLExact H11.
      }
      { (* Exists *)
        apply OLInPermutationL' in H6...
        rewrite H6 in HisD.
        rewrite H6...
        
         apply AppSOMEALLLeft in H9...
       
        rewrite <- perm_takeit_2...
        eapply LJSomeL;auto;intros.
        rewrite perm_takeit_2...
        apply H with (j:=j) (m:= x2)...
        apply H9 in H3.
        LLExact H3.
      }
    - destruct C...
      { rewrite !secCEncode in H8.
        apply downLeft in H8.
        apply OLInPermutationL in H8...
        
        apply LJCtLGen.
        rewrite H3...
        rewrite perm_takeit_2...
        apply LJWkLGen.
        rewrite app_comm_cons.
        rewrite <- H3. 
        apply AppALLSOMELeft in H9...
        
        apply LJAllL with (t:=x2)... 
        
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x1)...
     }
      { rewrite !secCEncode in H8.
        apply downLeft in H8.
        apply OLInPermutationL in H8...
        
        apply LJCtLGen.
        rewrite H3...
        rewrite perm_takeit_2...
        apply LJWkLGen.
        rewrite app_comm_cons.
        rewrite <- H3. 
        apply AppSOMEALLLeft in H9...
        
        
        apply LJSomeL;auto;intros.  
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x1)...
         }
    +
       apply FocusingPOSU in H3...
   
    ++  apply checkEncodeCasesD in H8... 
        apply OLInPermutationL' in H6...
        rewrite H6.
         rewrite <- perm_takeit_2...
       rewrite app_comm_cons.
        eapply H with (j:=j) (m:=x)...
        LLExact H9.
    ++  rewrite !secCEncode in H8.
        apply downLeft in H8.
        apply OLInPermutationL in H8...
        apply LJCtLGen.
        rewrite H3.
        assert(Permutation ((OO :: x0) ++ (OO :: x0) ++ D) (x0++ (OO :: (OO :: x0)) ++ D)) by perm.
        rewrite H6.
        apply LJWkLGen.
        rewrite <- H3.
        eapply H with (j:=j) (m:=x)...
        LLExact H9.
    + apply FocusingNEGU in H3...
   
    ++  apply checkEncodeCasesU in H6... 
        apply OLInPermutation' in H4...
        rewrite H4.
         rewrite <- perm_takeit_2...
       rewrite app_comm_cons.
        eapply H with  (j:=j) (m:=x)...
        LLExact H7.
    ++  rewrite !secCEncode in H6.
        apply upRight in H6.
        apply OLInPermutation in H6...
        apply LJCtRGen.
        rewrite H3.
        assert(Permutation ((OO :: x0) ++ (OO :: x0) ++ D') (x0++ (OO :: (OO :: x0)) ++ D')) by perm.
        rewrite H4.
        apply LJWkRGen.
        rewrite <- H3.
        eapply H with (j:=j) (m:=x)...
        LLExact H7.
   
Qed.

Lemma  SoundenessLJ' j L L' D D':
     mt j = true -> m4 j = true ->
      isOLFormulaL L ->
      isOLFormulaL L' ->
      isOLFormulaL D ->
      isOLFormulaL D' ->
      LJSeq (L++D) (L'++D') ->
      seq (OLTheoryI (i:=j) (a:=j)) (CEncode j (LEncode L) ++ CEncode loc (REncode L')) (LEncode D ++ REncode D') (> []).
 Proof with OLSolve.
 
 intros Mt Ft isFL isFL' isFD isFD' Hyp.
  eapply PosNegSetT with (a:=j) (b:=loc)...
  eapply SoundenessLJ with (j:=j) in Hyp...
  eapply exchangeCC'.
  2:{ exact Hyp. }
  rewrite LEncodeApp.
  rewrite REncodeApp.
  rewrite !CEncodeApp... perm.
  Qed.     
     

 Theorem AdequacyLJ j L L' D D': 
   mt j = true -> m4 j = true ->
   isOLFormulaL L ->
   isOLFormulaL L' ->
   isOLFormulaL D ->
   isOLFormulaL D' ->
   (LJSeq (L ++ D) (L' ++ D') <->
          seq (OLTheoryI (i:=j) (a:=j))
         (CEncode j (LEncode L) ++ CEncode loc (REncode L'))
         (LEncode D ++ REncode D') (> []) ).
Proof with sauto.
  intros.
  split;intros.
  + apply SoundenessLJ'... 
  + apply seqtoSeqN in H5... 
    apply Completeness in H5...
Qed.

End LJAdequacy. 

