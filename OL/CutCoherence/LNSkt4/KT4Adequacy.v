(** * System KT4 for classical logic encoded as an LL theory

This file encodes the inference rules of the system KT4. Since the
rules used are cut-coherent, the cut-elimination theorem applies for
this system.
 *)


Require Import MMLL.OL.CutCoherence.OLTactics.
Require Import MMLL.OL.CutCoherence.OLPosNeg.
Require Import MMLL.OL.CutCoherence.KT4.KT4Bipoles.
Require Import MMLL.SL.FLLReasoning.

Require Import Coq.Init.Nat.
Require Import MMLL.Misc.Permutations.

Export ListNotations.
Export LLNotations.
Set Implicit Arguments.

Section KT4Adequacy.
Context {SI : Signature}.
Context {USI : UnbSignature}.
Context {USInoD : UnbNoDSignature}.  

(** An inductive definition for KT4. This will be used to prove that
the LL encoding is sound and complete *)
Inductive KT4Seq : list uexp -> list uexp -> list uexp -> Prop :=
| KT4TRUE : forall D L L', KT4Seq D L ((t_cons TT)::L')
| KT4FALSE : forall D L L', KT4Seq D (t_cons FF :: L) L' 
| KT4init : forall D L L' F,  KT4Seq D (F:: L) (F::L')

| KT4AndL1 : forall D L F G L', KT4Seq D (F :: L) L' -> KT4Seq D ( (t_bin AND F G) :: L) L'
| KT4AndL2 : forall D L F G L', KT4Seq D (G :: L) L' -> KT4Seq D ( (t_bin AND F G) :: L) L'
| KT4AndR : forall D L F G L', KT4Seq D L (F::L') -> KT4Seq D L (G::L') -> KT4Seq D L (t_bin AND F G :: L')

| KT4OrL : forall D L F G L',  KT4Seq D (F :: L) L' -> KT4Seq D (G :: L) L' -> KT4Seq D ( (t_bin OR F G) :: L) L'
| KT4OrR1 : forall D L F G L', KT4Seq D L (F::L') -> KT4Seq D L (t_bin OR F G :: L')
| KT4OrR2 : forall D L F G L', KT4Seq D L (G::L') -> KT4Seq D L (t_bin OR F G :: L')
 
 (* Explicit exchange *)
| KT4ExL : forall D L L' Delta, Permutation L L' -> KT4Seq D L Delta -> KT4Seq D L' Delta
| KT4ExR : forall D L L' Delta, Permutation L L' -> KT4Seq D Delta L -> KT4Seq D Delta L'
(* Explicit contraction *)
| KT4CtL : forall D L L' F, KT4Seq D (F :: F :: L)  L' -> KT4Seq D (F :: L)  L'
| KT4CtR : forall D L L' F, KT4Seq D L (F :: F :: L')   -> KT4Seq D L (F :: L')

| KT4WkL : forall D L L' F, KT4Seq D L L' -> KT4Seq D (F :: L)  L'
| KT4WkR : forall D L L' F, KT4Seq D L L' -> KT4Seq D L (F :: L')

| KT4Dec : forall D L L' F, In F D  -> KT4Seq D (F::L) L' ->  KT4Seq D L L'

| KT4BoxL : forall D L F L', KT4Seq (F::D) L L' ->  KT4Seq D (t_ucon BOX F :: L) L'

| KT4BoxR : forall D L F L', KT4SeqT D L [ ] [ ] [F] ->  KT4Seq D L (t_ucon BOX F :: L')
    with
      KT4SeqT : list uexp -> list uexp -> list uexp -> list uexp -> list uexp -> Prop :=
       | KT4_K: forall F A A' B D L R, Permutation (F::A') A -> KT4SeqT A' B D (F::L) R ->  KT4SeqT A B D L R                                 
       | KT4_4: forall F A A' B D L R, Permutation (F::A') A -> KT4SeqT A' B (F::D) L R -> KT4SeqT A B D L R                                
       | KT4Release : forall A B D L R, KT4Seq D L R -> KT4SeqT A B D L R
.

 Notation "D ';' L '|--' R " := (KT4Seq D L R)  (at level 80).
 Notation "A ';' B '//' D ';' L '|--' R " := (KT4SeqT A B D L R)  (at level 80).
   
Hint Constructors KT4Seq : core .
Hint Constructors KT4SeqT : core .

Definition toBox D:= map (fun x => t_ucon BOX x) D.

  Theorem KT4SeqPerm1 A1  : forall A2 L R B D,
  Permutation A1 A2 -> KT4SeqT A2 B D L R -> KT4SeqT A1 B D L R .
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent A1.
  induction Hseq;intros;eauto using Permutation_in.
  symmetry in Hp.
   eapply KT4_K with (F:=F) (A':=A')...
   
  symmetry in Hp.
   eapply KT4_4 with (F:=F) (A':=A')...  
   
  Qed.
  
   Theorem KT4SeqPerm2 B1  : forall B2 L R A D,
  Permutation B1 B2 -> KT4SeqT A B2 D L R -> KT4SeqT A B1 D L R .
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent B1.
  induction Hseq;intros;eauto using Permutation_in.
  Qed.

  
  Theorem KT4SeqPerm4 L1  : forall L2 R A B D,
  Permutation L1 L2 -> KT4SeqT A B D L2 R -> KT4SeqT A B D L1 R .
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent L1.
  induction Hseq;intros;eauto using Permutation_in.
  apply KT4Release...
  eapply KT4ExL.
  exact (symmetry Hp).
  auto.
  Qed.

  Theorem KT4SeqPerm5 R1  : forall L R2 A B D,
  Permutation R1 R2 -> KT4SeqT A B D L R2 -> KT4SeqT A B D L R1.
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent R1.
  induction Hseq;intros;eauto using Permutation_in.
  apply KT4Release...
  eapply KT4ExR.
  exact (symmetry Hp).
  auto.
  Qed.
  
 Theorem KT4SeqPerm D1  : forall D2 L R,
  Permutation D1 D2 -> KT4Seq D2 L R -> KT4Seq D1 L R .
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent D1.
  induction Hseq;intros;eauto using Permutation_in.
  
  eapply KT4Dec with (F:=F)... 
  rewrite Hp...
  
  apply KT4BoxR.
  eapply KT4SeqPerm1 with (A2:=D)...
  Qed.
   
    
  Theorem KT4SeqPerm3 D1  : forall D2 L R A B,
  Permutation D1 D2 -> KT4SeqT A B D2 L R -> KT4SeqT A B D1 L R .
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent D1.
  induction Hseq;intros;eauto using Permutation_in.
  apply KT4Release...
  eapply KT4SeqPerm;eauto.
  Qed. 
  
    
  Global Instance KT4T_morph : 
  Proper ((@Permutation uexp) ==> (@Permutation uexp) ==>  (@Permutation uexp) ==> (@Permutation uexp) ==>  (@Permutation uexp)  ==> iff) (KT4SeqT).
Proof.
  unfold Proper; unfold respectful. 
  intros.
  split;intros;subst.
  - symmetry in H.
    symmetry in H0.
    symmetry in H1.
    symmetry in H2.
    symmetry in H3.
    eapply KT4SeqPerm1;eauto.
    eapply KT4SeqPerm2;eauto.
    eapply KT4SeqPerm3;eauto.
    eapply KT4SeqPerm4;eauto.
    eapply KT4SeqPerm5;eauto.
  - eapply KT4SeqPerm1;eauto.
    eapply KT4SeqPerm2;eauto.
    eapply KT4SeqPerm3;eauto.
    eapply KT4SeqPerm4;eauto.
    eapply KT4SeqPerm5;eauto.
Qed.

  Global Instance KT4_morph : 
  Proper ((@Permutation uexp) ==> (@Permutation uexp) ==> (@Permutation uexp) ==> iff) (KT4Seq).
Proof.
  unfold Proper; unfold respectful. 
  intros.
  split;intros;subst.
  1: eapply KT4SeqPerm with (D2:=x);eauto.
  symmetry in H0. 
  symmetry in H1.
  eapply KT4SeqPerm with (D2:=y);eauto.
Qed.

  Theorem KT4SeqTWkL : forall F L R A B D, KT4SeqT A B D L R -> KT4SeqT A B D (F::L) R .
  Proof with  CleanContext.
   intros.
   induction H;intros...
     rewrite <- H.
     eapply KT4_K with (F:=F0) (A':=A')...
     rewrite perm_swap...
     rewrite <- H.
     eapply KT4_4 with (F:=F0) (A':=A')...
  Qed. 
 
  Theorem KT4SeqTWkR : forall F L R A B D, KT4SeqT A B D L R -> KT4SeqT A B D L (F::R) .
  Proof with  CleanContext.
   intros.
   induction H;intros...
     rewrite <- H.
     eapply KT4_K with (F:=F0) (A':=A')...
     rewrite <- H.
     eapply KT4_4 with (F:=F0) (A':=A')...
 Qed.
  
  Theorem KT4SeqTWkL1 : forall F L R A B D, KT4SeqT A B D L R -> KT4SeqT (F::A) B D L R .
  Proof with  CleanContext.
   intros.
   induction H;intros...
     rewrite <- H.
     rewrite perm_swap.
      eapply KT4_K with (F:=F0) (A':=F::A')...
     rewrite <- H.
     rewrite perm_swap.
      eapply KT4_4 with (F:=F0) (A':=F::A')... 
 Qed.
 
   Theorem KT4SeqTWkL2 : forall F L R A B D, KT4SeqT A B D L R -> KT4SeqT A (F::B) D L R .
  Proof with  CleanContext.
   intros.
   induction H;intros...
     rewrite <- H.
      eapply KT4_K with (F:=F0) (A':=A')...
     rewrite <- H.
      eapply KT4_4 with (F:=F0) (A':=A')... 
 Qed.
 
 Theorem KT4SeqWkL' D : forall F L R, KT4Seq D L R -> KT4Seq (F::D) L R .
  Proof with  CleanContext.
   intros.
   induction H;intros...
   rewrite <- H...
   rewrite <- H...
    apply InPermutation in H...
     rewrite H.
     rewrite perm_swap.
     eapply KT4Dec with (F:=F0)...
     rewrite perm_swap...
     rewrite <- H...
     apply KT4BoxL.
     rewrite perm_swap...
     apply KT4BoxR.
     apply KT4SeqTWkL1...
 Qed.

   Theorem KT4SeqTWkL3 : forall F L R A B D, KT4SeqT A B D L R -> KT4SeqT A B (F::D) L R .
  Proof with  CleanContext.
   intros.
   induction H;intros...
     rewrite <- H.
      eapply KT4_K with (F:=F0) (A':=A')...
     rewrite <- H.
      eapply KT4_4 with (F:=F0) (A':=A')... 
      rewrite perm_swap...
    apply KT4Release...
    apply KT4SeqWkL'...  
 Qed.
 
 
 Theorem ImpGenInv A B D L R: 
    KT4SeqT A B D L R ->
    exists A1 A2 A3, Permutation A (A1++A2++A3) /\ KT4Seq (D++A1) (L++A2) R.
  Proof with  CleanContext.
   intros.
   induction H;intros...
   - eexists x.
     exists (F::x0).
     exists x1.
     split...
     rewrite <- H.
     rewrite H2...
     rewrite <- Permutation_middle...
   - eexists (F::x).
     exists x0.
     eexists x1.
     split...
     rewrite <- H.
     rewrite H2...
     rewrite <- Permutation_middle...
   - exists [].
     exists [].
     exists A.
     split...
 Qed.    
 

 Theorem ImpGen A : forall D A1 A2 A3 B L R, 
    Permutation A (A1++A2++A3) -> KT4Seq (D++A1) (L++A2) R ->
    KT4SeqT A B D L R.  
  Proof with  CleanContext.
   induction A;intros...
   checkPermutationCases H.
   - rewrite H1 in H0.
     rewrite <- Permutation_middle in H0.
     rewrite app_comm_cons in H0.
     eapply IHA with (B:=B) (A3:=A3) in H0...
     apply KT4_4 with (F:=a) (A':=A)...
   - checkPermutationCases H1.
     + rewrite H1 in H0.
       rewrite <- Permutation_middle in H0.
       rewrite app_comm_cons in H0.
       eapply IHA with (B:=B) (A3:=A3) in H0...
       apply KT4_K with (F:=a) (A':=A)...
       rewrite <- H2.
       rewrite <- H3...
     + apply KT4SeqTWkL1...
       eapply IHA with (A1:=A1) (A2:=A2) (A3:=x0)... 
       rewrite <- H2.
       rewrite <- H3...
 Qed.    
    

  
Theorem KT4CtLGen C : forall D L L', KT4Seq D (C ++ C ++ L)  L' -> KT4Seq D (C ++ L) L'.
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply KT4CtL.
  rewrite Permutation_cons_append.
  rewrite Permutation_cons_append.
  do 2 rewrite app_assoc_reverse.
  eapply IHC.
  assert(Hs: Permutation (C ++ C ++ L ++ [a] ++ [a]) ((a :: C) ++ (a :: C) ++ L)) by perm.
  rewrite Hs...
Qed.


Theorem KT4CtRGen D C : forall L L', KT4Seq D L (C ++ C ++ L') -> KT4Seq D L (C ++ L').
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply KT4CtR.
  rewrite Permutation_cons_append.
  rewrite Permutation_cons_append.
  do 2 rewrite app_assoc_reverse.
  eapply IHC.
  assert(Hs: Permutation (C ++ C ++ L' ++ [a] ++ [a]) ((a :: C) ++ (a :: C) ++ L')) by perm.
  rewrite Hs...
Qed.

Theorem KT4WkLGen C : forall D L L', KT4Seq D L  L' -> KT4Seq D (C ++ L) L'.
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply KT4WkL...
Qed.

Theorem KT4WkRGen C : forall D L L', KT4Seq D L  L' -> KT4Seq D L (C++L').
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply KT4WkR...
Qed.

Theorem KT4WkLGen' C : forall D L L', KT4Seq D L  L' -> KT4Seq (C++D) L L'.
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply KT4SeqWkL'...
Qed.

Lemma storeAll X : forall D L th, IsPositiveAtomFormulaL (Arrow2LL X) ->
  seq th L ((Arrow2LL X)++D) (UP []) -> seq th L D X.
Proof with sauto;SLSolve;OLSolve.
  destruct X;simpl;intros...
  * revert dependent L.
    revert D.
    revert dependent l.
    intro.
    induction l;intros...
    inversion H...
    inversion H3...
    LLStore.
    apply IHl... LLExact H0.
    LLStore.
    apply IHl... LLExact H0.
  * inversion H...
    inversion H3...
 Qed. 
   
Lemma storeAllN X : forall n D L th, IsPositiveAtomFormulaL (Arrow2LL X) ->
  seqN th n L ((Arrow2LL X)++D) (UP []) -> exists m, m <= S n +length (Arrow2LL X) /\ 
  seqN th m L D X.
Proof with sauto;SLSolve;OLSolve.
  destruct X;simpl;intros...
  * revert dependent L.
    revert D.
    revert dependent l.
    revert dependent n.
    intro.
    induction l;intros...
    exists n...
    inversion H...
    inversion H3...
    assert(exists m : nat,
        m <= S n + length l /\ seqN th m L (d| A |::D) (UP l)).
    apply IHl... LLExact H0.
    destruct H2...
    eexists (S x)...
    simpl...
     assert(exists m : nat,
        m <= S n + length l /\ seqN th m L (u| A |::D) (UP l)).
    apply IHl... LLExact H0.
    destruct H2...
    eexists (S x)...
    simpl...
  * inversion H...
    inversion H3...
    eexists (S (S n))...
    eexists (S (S n))...
 Qed.

Lemma storeAllInv X : forall D L th, IsPositiveAtomFormulaL (Arrow2LL X) ->
  seq th L D X -> seq th L ((Arrow2LL X)++D) (UP []).
Proof with sauto;SLSolve;OLSolve.
  destruct X;simpl;intros...
  * revert dependent L.
    revert D.
    revert dependent l.
    intro.
    induction l;intros...
    rewrite Permutation_cons_append.
    rewrite app_assoc_reverse.
    apply IHl...
    inversion H...
    inversion H0;inversion H3...
  * inversion H...
    inversion H0;inversion H3...
    all: inversion H7...
 Qed.  
  
Lemma adequacy_aux a j F L D X: 
mt a = true ->
mt j = true -> m4 j = true ->
IsPositiveAtomFormulaL X ->
IsPositiveAtomFormulaL D ->
IsPositiveAtomFormulaL (second L) ->
 isOLFormula (t_ucon BOX F) ->          
           seq (KT4 j) ((j, d|F |)::L) D (UP X) <-> 
           seq (KT4 j) ((a,d| t_ucon BOX F|)::L) D (UP X).
Proof with CleanContext;SLSolve;OLSolve. 
  intros aT jT jF isFX. split;intros.
 * 
   apply storeAll...
   apply storeAllInv in H2...
   TFocus (UnBipole (BOX_BODY j) Left F).
   apply ooth_boxC.
   constructor... inversion H3.
   LLTensor (@nil oo) (X++D)...
   simpl... solveLL. 
   simpl. LLRelease. LLStoreC. LLSwap.
   apply weakening...
   solveSignature1.
 * 
   apply storeAll...
   apply storeAllInv in H2...
   apply seqtoSeqN in H2... 
   remember (X++D) as Y.
   assert(IsPositiveAtomFormulaL Y). 
   rewrite HeqY. OLSolve.
   simpl in *. rewrite <- HeqY.
   rewrite <- HeqY in H2. 
   clear HeqY.
   clear H isFX.
   rename H3 into H.
   revert dependent Y.
   revert dependent L.
   revert dependent F.
   revert dependent j.
   induction x using strongind;intros...
   - inversion H2...
   - inversion H2...
     -- apply RemoveNotPos1 in H6;sauto...
         inversion H4; inversion H5...
     -- apply InUNotPos in H8;sauto...
     -- apply RemoveNotPos2 in H8;sauto...
     -- inversion H5...
   + inversion H4...
     ++
        apply BipoleReasoning in H7...
        +++
        TFocus (CteBipole TT_BODY Right).
        LLTensor [u| t_cons TT | ] x1.
        simpl... 
        +++
        checkPermutationCases  H13.
        TFocus (CteBipole TT_BODY Right).
        LLTensor (@nil oo) Y.
        apply weakening... solveSignature1.
        solveLL...
        simpl... 
     ++
        apply BipoleReasoning in H7...
        +++
         inversion H11...
         +++
         inversion H11...
    ++
        apply BipoleReasoning in H7...
        +++
         inversion H11...
         +++
         inversion H11...
    ++
        apply BipoleReasoning in H7...
        +++
        TFocus (CteBipole FF_BODY Left).
        LLTensor [d| t_cons FF | ] x1.
        simpl... 
        +++
        checkPermutationCases  H13.
        TFocus (CteBipole FF_BODY Left).
        LLTensor (@nil oo) Y.
        apply weakening... solveSignature1.
        solveLL...
        simpl... 
   + inversion H4...
     ++
        apply BipoleReasoning in H7...
        +++
        TFocus (BinBipole AND_BODY Right F1 G).
        LLTensor [u| t_bin AND F1 G | ] x1.
        apply FocusingWith in H11...
        simpl. 
        LLRelease. LLWith.
        1-2: LLStore.
        apply H in H11...
        apply H in H13...
        +++
        checkPermutationCases H13.
        TFocus (BinBipole AND_BODY Right F1 G).
        LLTensor (@nil oo) Y.
        apply weakening... solveSignature1.
        solveLL...
        apply FocusingWith in H11...
        simpl. 
        LLRelease. LLWith.
        1-2: LLStore.
        apply H in H14...
        apply H in H15...
     ++
        apply BipoleReasoning in H7...
        +++
        TFocus (BinBipole AND_BODY Left F1 G).
        LLTensor [d| t_bin AND F1 G | ] x1.
        apply FocusingPlus in H11...
        1: simpl; LLPlusL; LLRelease; LLStore.
        2: simpl; LLPlusR; LLRelease; LLStore. 
        1-2: apply H in H10...
        +++
        checkPermutationCases H13.
        TFocus (BinBipole AND_BODY Left F1 G).
        LLTensor (@nil oo) Y.
        apply weakening... solveSignature1.
        solveLL...
        apply FocusingPlus in H11...
        simpl. 
        1: simpl; LLPlusL; LLRelease; LLStore.
        2: simpl; LLPlusR; LLRelease; LLStore. 
        1-2: apply H in H13...
     ++
        apply BipoleReasoning in H7...
        +++
        TFocus (BinBipole OR_BODY Right F1 G).
        LLTensor [u| t_bin OR F1 G | ] x1.
        apply FocusingPlus in H11...
        1: simpl; LLPlusL; LLRelease; LLStore.
        2: simpl; LLPlusR; LLRelease; LLStore. 
        1-2: apply H in H10...
        +++
        checkPermutationCases H13.
        TFocus (BinBipole OR_BODY Right F1 G).
        LLTensor (@nil oo) Y.
        apply weakening... solveSignature1.
        solveLL...
        apply FocusingPlus in H11...
        simpl. 
        1: simpl; LLPlusL; LLRelease; LLStore.
        2: simpl; LLPlusR; LLRelease; LLStore. 
        1-2: apply H in H13...
     ++
        apply BipoleReasoning in H7...
        +++
        TFocus (BinBipole OR_BODY Left F1 G).
        LLTensor [d| t_bin OR F1 G | ] x1.
        apply FocusingWith in H11...
        simpl. 
        LLRelease. LLWith.
        1-2: LLStore.
        apply H in H11...
        apply H in H13...
        +++
        checkPermutationCases H13.
        TFocus (BinBipole OR_BODY Left F1 G).
        LLTensor (@nil oo) Y.
        apply weakening... solveSignature1.
        solveLL...
        apply FocusingWith in H11...
        simpl. 
        LLRelease. LLWith.
        1-2: LLStore.
        apply H in H14...
        apply H in H15...
   + apply FocusingInitRuleU in H7...
        ++ 
        TFocus (RINIT OO).
        LLTensor [u| OO |] [d| OO |].
        ++
        checkPermutationCases H10.
        TFocus (UnBipole (BOX_BODY j) Right F).
        do 2 constructor;auto.
        inversion H1.
        LLTensor [u| t_ucon BOX F |] (@nil oo).
        simpl. createWorld. solveSignature1.
        apply GenK4RelUT' with (C4:=[(j, d| F |)]) (CK:=[]) (CN:=L)...
        solveSignature1.
        constructor...
        reflexivity.
        simpl... LLStore.
        TFocus (RINIT F).
        apply ooth_initC... 
        inversion H1.
        LLTensor [u| F |] (@nil oo).
        solveLL.
        TFocus (RINIT OO).
        LLTensor [u| OO |] (@nil oo).
        apply weakening... solveSignature1.
        solveLL...
      ++
        checkPermutationCases H10. 
        TFocus (RINIT OO).
        LLTensor (@nil oo) [d| OO |] .
        apply weakening... solveSignature1.
        solveLL...
      ++  
        checkPermutationCases H10. 
        checkPermutationCases H8. 
       TFocus (UnBipole (BOX_BODY j) Right F).
        do 2 constructor;auto.
        inversion H1.
        LLTensor. 
        apply weakening... solveSignature1.
        solveLL...
        simpl. createWorld. solveSignature1.
        apply GenK4RelUT' with (C4:=[(j, d| F |)]) (CK:=[]) (CN:=L)...
        solveSignature1.
        constructor...
        reflexivity.
        simpl... LLStore.
        TFocus (RINIT F).
        apply ooth_initC... 
        inversion H1.
        LLTensor [u| F |] (@nil oo).
        solveLL.
        TFocus (RINIT OO).
        LLTensor.
        all: apply weakening...
        1-3: solveSignature1.
        all: solveLL...
   + inversion H4...        
     ++
        apply BipoleReasoning in H7...
        +++
        TFocus  (UnBipole (BOX_BODY j) Right F1).
        LLTensor [u| t_ucon BOX F1 |] x1.
        apply FocusingBang' in H11... 
        checkPermutationCases H11.
        1-2: simpl; createWorld; solveSignature1.
        LLrewrite H8 in H17. 
        apply H in H17...
        apply GenK4RelUT' with (C4:=[(j, d| F |)]++x0) (CK:=[]) (CN:=x3)...
        solveSignature1.
        rewrite H8 in H13...
        inversion H13...
        constructor...
        
        rewrite H8 in H9...
        inversion H9...
        constructor...
        
         rewrite H8 in H14...
        inversion H14...
        constructor...
       
        reflexivity.
        rewrite <- H11...
        simpl...
        OLSolve.
        symmetry in H11.
        srewrite  H11 in H0.
        OLSolve.
        rewrite map_app in H0.
        OLSolve. 
        apply GenK4RelUT' with (C4:=x2) (CK:=[]) (CN:=(j, d| F |)::x0)...
        solveSignature1.
        rewrite <- H11...
        simpl...
        LLStore.
        HProof.
        +++
        checkPermutationCases H13.
        TFocus  (UnBipole (BOX_BODY j) Right F1).
        LLTensor (@nil oo) Y.
        apply weakening... solveSignature1.
        solveLL...
        
        apply FocusingBang' in H11... 
        checkPermutationCases H14.
        1-2: simpl; createWorld; solveSignature1.
        LLrewrite H11 in H19. 
        apply H in H19...
        apply GenK4RelUT' with (C4:=[(j, d| F |)]++x0) (CK:=[]) (CN:=x5)...
        solveSignature1.
        rewrite H11 in H15...
        inversion H15...
        constructor...
        
        rewrite H11 in H13...
        inversion H13...
        constructor...
        
        rewrite H11 in H16...
        inversion H16...
        constructor...
        reflexivity.
        rewrite <- H14...
        simpl...
        OLSolve.
        symmetry in H14.
        srewrite  H14 in H0.
        OLSolve.
        rewrite map_app in H0.
        OLSolve. 
        apply GenK4RelUT' with (C4:=x4) (CK:=[]) (CN:=(j, d| F |)::x0)...
        solveSignature1.
        rewrite <- H14...
        simpl...
        LLStore.
        HProof.
     ++
        apply BipoleReasoning in H7...
        +++
        simpl in H11.
        TFocus (UnBipole (BOX_BODY j) Left F1).
        simpl in H12.
        LLTensor [d| t_ucon BOX F1 | ] x1.
        apply FocusingQuest in H11...
        simpl. 
        LLRelease. LLStoreC.
        LLSwapC H9.
        apply H in H9...
        LLExact H9.
        +++
        checkPermutationCases H13.
        
        2:{
        TFocus (UnBipole (BOX_BODY j) Left F1).
        LLTensor (@nil oo) Y.
        apply weakening... solveSignature1.
        solveLL...
        apply FocusingQuest in H11...
        simpl. 
        LLRelease. LLStoreC.
        LLSwapC H13.
        apply H in H13...
        LLExact H13. }
   
         apply FocusingQuest in H11... 
         LLSwapC H8.
         apply H in H8...
         apply contraction in H8...
         solveSignature1.
      + apply BipoleReasoning in H7...
        ++ 
        TFocus(POS OO loc).
        LLTensor [d| OO |] x1.
        LLRelease. LLStoreC.
        apply FocusingQuest in H10...
        LLSwapC H9.
        apply H in H9...
        LLExact H9.
      ++ 
         checkPermutationCases H12.
         
         2:{
         TFocus(POS OO loc).
         LLTensor (@nil oo) Y.
         apply weakening... solveSignature1.
         solveLL.
         LLRelease. LLStoreC.
         apply FocusingQuest in H10...
         LLSwapC H12.
         apply H in H12...
         LLExact H12. }
         
         apply FocusingQuest in H10... 
         apply ContractionLoc in H8...
         apply H in H8...
         solveSignature1.
   + apply BipoleReasoning in H7...
        ++ 
        TFocus(NEG OO loc).
        LLTensor [u| OO |] x1.
        LLRelease. LLStoreC.
        apply FocusingQuest in H10...
        LLSwapC H9.
        apply H in H9...
        LLExact H9.
      ++ 
         checkPermutationCases H12.
         TFocus(NEG OO loc).
         LLTensor (@nil oo) Y.
         apply weakening... solveSignature1.
         solveLL.
         LLRelease. LLStoreC.
         apply FocusingQuest in H10...
         LLSwapC H12.
         apply H in H12...
         LLExact H12.
 -- solveSignature1.
 Qed.
 
  
Lemma adequacy_aux_instance_loc j F L D X: 
mt j = true -> m4 j = true ->
IsPositiveAtomFormulaL X ->
IsPositiveAtomFormulaL D ->
IsPositiveAtomFormulaL (second L) ->
 isOLFormula (t_ucon BOX F) ->          
           seq (KT4 j) ((j, d|F |)::L) D (UP X) <-> 
           seq (KT4 j) ((loc,d| t_ucon BOX F|)::L) D (UP X).
Proof with CleanContext;SLSolve;OLSolve. 
  intros jT jF. split;intros.
  - apply adequacy_aux... solveSignature1.
  - apply adequacy_aux in H3... solveSignature1.
Qed.  
 


Lemma adequacy_auxK4_instance_loc j F L D : 
mt j = true -> m4 j = true ->
IsPositiveAtomFormulaL (second L) ->
IsPositiveAtomFormulaL (second D) ->
 isOLFormula F ->          
   tri_bangK4' (KT4 j) D j ((j, d|F |)::L) [] (UP []) <-> 
   tri_bangK4' (KT4 j) D j ((loc,d| t_ucon BOX F|)::L) [] (UP []).
Proof with CleanContext;SLSolve;OLSolve. 
   intros jT jF. split;intros.
 * apply InvSubExpPhaseUTK4' in H2... 
   apply GenK4Rel' with (C4:= x) 
                        (CK:=[])
                        (CN:=x0)...
   solveSignature1.                     
   simpl...
  apply adequacy_aux_instance_loc;auto. 
  rewrite secondApp.
  rewrite PlusT_fixpoint'... 
  srewrite H3 in H0.
  rewrite map_app in H0...
  rewrite PlusT_fixpoint'...
  solveSignature1.
  solveSignature1.
 * apply InvSubExpPhaseUTK4' in H2... 
   apply GenK4Rel' with (C4:= x) 
                        (CK:=[])
                        (CN:=x0)...
   solveSignature1.                     
   simpl...
  apply adequacy_aux_instance_loc;auto. 
  rewrite secondApp.
  rewrite PlusT_fixpoint'... 
  srewrite H3 in H0.
  rewrite map_app in H0...
  rewrite PlusT_fixpoint'...
  solveSignature1.
  solveSignature1.
 Qed.

Lemma adequacy_auxK4 a j F L D : 
mt j = true -> m4 j = true ->
mt a = true -> m4 a = true ->
IsPositiveAtomFormulaL (second L) ->
IsPositiveAtomFormulaL (second D) ->
 isOLFormula F ->          
   tri_bangK4' (KT4 j) D j ((j, d|F |)::L) [] (UP []) <-> 
   tri_bangK4' (KT4 j) D j ((a,d| t_ucon BOX F|)::L) [] (UP []).
Proof with CleanContext;SLSolve;OLSolve. 
   intros aT aF jT jF. split;intros.
 * apply InvSubExpPhaseUTK4' in H2... 
   apply GenK4Rel' with (C4:= x) 
                        (CK:=[])
                        (CN:=x0)...
  solveSignature1.
  simpl...                      
  apply adequacy_aux;auto. 
  rewrite secondApp.
  rewrite PlusT_fixpoint'. 
  OLSolve.
  srewrite H3 in H0.
  rewrite map_app in H0...
  auto.
  rewrite PlusT_fixpoint'...
  solveSignature1.
  solveSignature1.
 *  apply InvSubExpPhaseUTK4' in H2;solveSignature1... 
   
  apply GenK4Rel' with (C4:= x) 
                        (CK:=[])
                        (CN:=x0);sauto;solveSignature1...
  simpl... 
  rewrite PlusT_fixpoint'. 
 rewrite <- app_comm_cons in H10. 
  apply adequacy_aux in H10;sauto.
  rewrite secondApp.
  OLSolve.
  srewrite H3 in H0.
  rewrite map_app in H0...
  auto.
 Qed.

Lemma adequacy_auxK4' a j F L D Y X: 
mt j = true -> m4 j = true ->
mt a = true -> m4 a = true ->
lt j a ->
IsPositiveAtomFormulaL X ->
IsPositiveAtomFormulaL (second L) ->
IsPositiveAtomFormulaL (second D) ->
IsPositiveAtomFormulaL Y ->
 isOLFormula F ->          
   tri_bangK4' (KT4 j) ((j, d|F |)::D) j L Y (UP X) <-> 
   tri_bangK4' (KT4 j) ((a,d| t_ucon BOX F|)::D) j L Y (UP X).
Proof with CleanContext;SLSolve;OLSolve. 
   intros aT aF jT jF ltaj. split;intros.
 * apply InvSubExpPhaseUTK4' in H4;solveSignature1...
   checkPermutationCases H5.
   -
   assert(SetK4 x1).
   rewrite H5 in H7.
   solveSE.
  assert(LtX j x1).
  rewrite H5 in H6.
  solveLT. 
  assert(SetT x1). 
   rewrite H5 in H10.
   solveSE.
   
    
   copyK4 a (d| t_ucon BOX F |) D...
   rewrite plustpropT...
   apply GenK4RelUT' with (C4:= x1) 
                        (CK:=[])
                        (CN:=x0);solveSignature1...
  simpl...                        
  rewrite <- Permutation_cons_append.
  rewrite <- app_comm_cons.
  apply adequacy_aux;auto. 
  rewrite secondApp.
  OLSolve.
  
  symmetry in H11.
  srewrite H11 in H1.
  rewrite map_app in H1...
  srewrite H5 in H12.
  LLExact H12.
  - 
   rewrite Permutation_cons_append. 
   apply weakeness_mutual'...
   solveSignature1.
   apply GenK4RelUT' with (C4:= x) 
                        (CK:=[])
                        (CN:=x1);solveSignature1...
   simpl...
 * apply InvSubExpPhaseUTK4' in H4;solveSignature1...
   checkPermutationCases H5.
   -
   assert(SetK4 x1).
   rewrite H5 in H7.
   solveSE.
  assert(LtX j x1).
  rewrite H5 in H6.
  solveLT. 
  assert(SetT x1). 
   rewrite H5 in H10.
   solveSE.
   
    
   copyK4 j (d|  F |) D...
   reflexivity.
   rewrite plustpropT...
   apply GenK4RelUT' with (C4:= x1) 
                        (CK:=[])
                        (CN:=x0);solveSignature1...
  simpl...
  srewrite H5 in H12.
  LLPermH H12 ((a, d| t_ucon BOX F |) :: L++x1).
  apply adequacy_aux in H12;auto. 
  LLExact H12.
  rewrite secondApp.
  OLSolve.
  
  symmetry in H11.
  srewrite H11 in H1.
  rewrite map_app in H1...
  - 
   rewrite Permutation_cons_append. 
   apply weakeness_mutual'...
   solveSignature1.
   apply GenK4RelUT' with (C4:= x) 
                        (CK:=[])
                        (CN:=x1);solveSignature1...
   simpl...
 Qed.
 
  Theorem  SoundenessKT4T j A B D R L
     (Mj: mt j = true) (Fj: m4 j = true)
     (isFL: isOLFormulaL L) (isFR: isOLFormulaL R)
     (isFD: isOLFormulaL D) (isFA: isOLFormulaL A) : 
     forall  (Hyp: KT4SeqT A B D L R), 
     tri_bangK4' (KT4 j) (CEncode j (LEncode A)) j
     (CEncode j (LEncode D) ++ (CEncode loc (LEncode L) ++ CEncode loc (REncode R))) [] (UP []) with 
      SoundenessKT4 j D L R
     (Mj: mt j = true) (Fj: m4 j = true)
     (isFD: isOLFormulaL D) (isFL: isOLFormulaL L) (isFR: isOLFormulaL R)  : 
     forall (Hyp: KT4Seq D L R), 
     seq (KT4 j) 
     (CEncode j (LEncode D) ++ (CEncode loc (LEncode L) ++ CEncode loc (REncode R))) [] (UP []).
Proof with CleanContext;SLSolve;OLSolve.
  * clear SoundenessKT4T.
  intros.
  induction Hyp.
  + 
    symmetry in H.
    srewrite H...
    apply IHHyp in isFD...
    clear IHHyp.
    copyK4 j (d| F |) (CEncode j (LEncode A')).
    reflexivity.
    rewrite plustpropT...
    rewrite Permutation_app_comm.
    apply ContractionLocK4'...
    solveSignature1.
    eapply exchangeCCKK4.
    2:{ exact isFD. } 
    simpl... 
    rewrite H in isFA.
    OLSolve. 
  + 
    symmetry in H.
    srewrite H...
    apply IHHyp in isFR...
    clear IHHyp.
    copyK4 j (d| F |) (CEncode j (LEncode A')).
    reflexivity.
    rewrite plustpropT...
    eapply exchangeCCKK4.
    2:{ exact isFR. } 
    simpl...
    rewrite H in isFA.
    OLSolve. 
  + eapply SoundenessKT4 with (j:=j)  in H...
      finishExp...
  * clear SoundenessKT4. 
    intros.
    induction Hyp.
     + (* True on the right *)
    TFocus (CteBipole TT_BODY Right).
    constructor;constructor;auto.
    inversion H.
    LLTensor.
    simpl...
    rewrite  Permutation_cons_append...
    rewrite !app_assoc...
    apply weakeningGen...
    init2 loc (@nil TypedFormula).
    solveSignature1.
    simpl... 
   + (* false on the left *)
    TFocus (CteBipole FF_BODY Left).
    constructor;constructor;auto.
    inversion H.
    LLTensor.
    simpl...
    rewrite  Permutation_cons_append...
    rewrite !app_assoc...
    apply weakeningGen...
    init2 loc (@nil TypedFormula).
    solveSignature1.
    simpl... 
   +
    TFocus (RINIT F)...
    apply ooth_initC...
    inversion H.
    LLTensor.
    simpl...
    rewrite  Permutation_cons_append...
    rewrite !app_assoc_reverse...
    apply weakeningGen...
    apply weakeningGen...
    apply weakeningGen_rev...
    init2 loc (CEncode loc (REncode L')).
    solveSignature1.
    simpl... 
    rewrite  Permutation_cons_append...
    rewrite !app_assoc...
    apply weakeningGen...
    init2 loc (@nil TypedFormula).
    solveSignature1.
   +
    TFocus (BinBipole AND_BODY Left F G)...
    apply ooth_rulesC...
    constructor...
    inversion H.
    LLTensor. 
    simpl...
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen...
    init2 loc (@nil TypedFormula).
    solveSignature1.
   
    LLPlusL. LLRelease. LLStore.
    simpl...
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen_rev...
    apply PosF with (a:=loc)...
    intro;intros...
    apply IHHyp in isFR as Hs...
    simpl in Hs.
    simpl.
    LLExact Hs.
   + 
    TFocus (BinBipole AND_BODY Left F G)...
    apply ooth_rulesC...
    constructor...
    inversion H.
    LLTensor. 
    simpl...
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen...
    init2 loc (@nil TypedFormula).
    solveSignature1.
   
    LLPlusR. LLRelease. LLStore.
    simpl...
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen_rev...
    apply PosF with (a:=loc)...
    intro;intros...
    apply IHHyp in isFR as Hs...
    simpl in Hs.
    simpl.
    LLExact Hs.
    +
    TFocus (BinBipole AND_BODY Right F G)...
    apply ooth_rulesC...
    constructor...
    inversion H.
    LLTensor...
    simpl...
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen...
    init2 loc (@nil TypedFormula).
    solveSignature1.
    
    simpl. LLRelease. LLWith; LLStore.
    1-2: simpl; rewrite Permutation_cons_append...
    1-2: rewrite !app_assoc.
    1-2: apply weakeningGen_rev...
   
    1-2: apply NegF with (a:=loc)...
    1,3: intro; intros...
    apply IHHyp1 in isFL...
    simpl in isFL...
    simpl...
    LLExact isFL.
    apply IHHyp2 in isFL...
    simpl in isFL...
    simpl...
    LLExact isFL.
    +
    TFocus (BinBipole OR_BODY Left F G)...
    apply ooth_rulesC...
    constructor...
    inversion H.
    LLTensor...
    simpl...
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen...
    init2 loc (@nil TypedFormula).
    solveSignature1.
    
    simpl. LLRelease. LLWith; LLStore.
    1-2: simpl; rewrite Permutation_cons_append...
    1-2: rewrite !app_assoc.
    1-2: apply weakeningGen_rev...
   
    1-2: apply PosF with (a:=loc)...
    1,3: intro; intros...
    apply IHHyp1 in isFD...
    simpl in isFD...
    simpl...
    LLExact isFD.
    apply IHHyp2 in isFR...
    simpl in isFR...
    simpl...
    LLExact isFR.
   + 
    TFocus (BinBipole OR_BODY Right F G)...
    apply ooth_rulesC...
    constructor...
    inversion H.
    LLTensor. 
    simpl...
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen...
    init2 loc (@nil TypedFormula).
    solveSignature1.
   
    LLPlusL. LLRelease. LLStore.
    simpl...
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen_rev...
    apply NegF with (a:=loc)...
    intro;intros...
    apply IHHyp in isFD... 
    simpl in isFD...
    simpl...
    LLExact isFD...
   + 
    TFocus (BinBipole OR_BODY Right F G)...
    apply ooth_rulesC...
    constructor...
    inversion H.
    LLTensor. 
    simpl...
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen...
    init2 loc (@nil TypedFormula).
    solveSignature1.
   
    LLPlusR. LLRelease. LLStore.
    simpl...
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen_rev...
    apply NegF with (a:=loc)...
    intro;intros...
    apply IHHyp in isFD... 
    simpl in isFD...
    simpl...
    LLExact isFD...
   + (* exchange *)
    srewrite (symmetry H)...
    apply IHHyp...
   + (* exchange *)
    srewrite (symmetry H)...
    apply IHHyp...    
  + (* contraction *)
    eapply @contraction with (F:=(loc, d| F |)); solveSignature1...
    apply IHHyp in isFR...
    simpl in isFR... 
    simpl...
    LLExact isFR.
    OLSolve.
    simpl...
  + (* contraction *)
    eapply @contraction with (F:=(loc, u| F |));solveSignature1...
    apply IHHyp in isFL...
    simpl in isFL...
    simpl... 
    LLExact isFL.
    OLSolve.
    apply in_or_app.
    right.
    simpl...
  + (* weakening *)
    simpl. rewrite Permutation_midle.
    apply weakening;solveSignature1...
    apply IHHyp...
   + (* weakening *)
    simpl. rewrite Permutation_cons_append.
    rewrite !app_assoc.
    apply weakeningGen_rev;solveSignature1...
    rewrite !app_assoc_reverse.
    apply IHHyp...
  + (* decide T *)
    apply InPermutation in H... 
    srewrite H...
    simpl...
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    rewrite Permutation_app_comm.
    apply ContractionL'...
     
    rewrite H in isFD.
    assert(isOLFormulaL (F :: L))...
    apply IHHyp in H0...
    simpl in H0...
    simpl...
    eapply exchangeCC'.
    2:{ exact H0. }
    simpl...
    srewrite H... 
  + (* box left *)
    assert(isOLFormulaL (F :: D))...
    apply IHHyp in H...
    simpl...
    rewrite <- Permutation_middle.
    apply adequacy_aux_instance_loc;auto. 
    rewrite !secondApp.
    rewrite !secCEncode...
    OLSolve. inversion isFL... OLSolve.
    OLSolve. OLSolve.
  + (* box right *)
    TFocus (UnBipole (BOX_BODY j) Right F).
    apply ooth_boxC.
    constructor...
    inversion H0.
    LLTensor...
    simpl...
    rewrite Permutation_cons_append.
    apply weakeningGen...
    apply weakeningGen...
    apply weakeningGen...
    init2 loc (@nil TypedFormula).
    solveSignature1.
    
    simpl.
    apply SoundenessKT4T with (j:=j) in H...
    apply InvSubExpPhaseUTK4' in H;solveSignature1...
    simpl in H7...
   
   simpl.
   rewrite Permutation_cons_append.
   
   createWorld. solveSignature1.
   rewrite !app_assoc.
   apply weakeness_mutual'...
   solveSignature1.
   apply destructCEncode in H0...
  (*  apply destructLEncode in H7...
   rewrite PlusT_fixpoint' in H5...
   *) 
   apply CEncodePerm with (i:=j) in H9.
   rewrite H9.
   rewrite CEncodeApp.
   rewrite !app_assoc_reverse.
   apply weakeness_mutualGen'...
   eapply @GenK4RelUT' with (C4:=x) (CK:=[]) (CN:=[])...
   solveSignature1.
   simpl...
   LLStore.
   apply NegF with (a:=loc)...
   intro;intros...
 Qed.
  
Tactic Notation "decideT" := 
       match goal with
        | [ |- ?P :: ?X; ?L |-- ?R] =>  eapply @KT4Dec with (F:= P);sauto
       end.
       
Tactic Notation "decideTW" := 
       match goal with
        | [ |- ?P :: ?X; ?L |-- ?R] =>  eapply @KT4Dec with (F:= P);sauto; try apply KT4SeqTWkL1
       end.

Lemma PermSecond (L1 L2: list TypedFormula): 
     Permutation L1 L2 ->
     Permutation (second L1) (second L2) .
  Proof.
  eapply Permutation_map.   
  Qed.
 
(** Completeness theorem *)  
Theorem Completeness: forall n j D L1 L2 R1 R2, 
    m4 j = true -> mt j = true ->
    isOLFormulaL D ->
    isOLFormulaL L1 ->
    isOLFormulaL L2 ->
    isOLFormulaL R1 ->
    isOLFormulaL R2 ->
    seqN (KT4 j) n 
    (CEncode j (LEncode D) ++ (CEncode loc (LEncode L1) ++ CEncode loc (REncode R1))) (LEncode L2 ++  REncode R2) 
    (UP []) ->
    KT4Seq D (L1++L2) (R1++R2).
Proof with CleanContext;solveSE;OLSolve.
  intro.
  induction n using strongind; intros j D L1 L2 R1 R2 Fj Mj HisD HisL1 HisL2 HisR1 HisR2 Hseq; 
  inversion Hseq...
  * apply RemoveNotPos1 in H2;sauto...
     inversion H0; inversion H1...
     OLSolve. OLSolve.
  * apply InUNotPos in H4;sauto.
    rewrite !secondApp.
    rewrite !secCEncode.
    OLSolve. all: OLSolve.
  * apply RemoveNotPos2 in H4;sauto.
    rewrite !secondApp.
    rewrite !secCEncode.
    OLSolve. all:OLSolve.
  * inversion H1...
  + inversion H0...
  ++ (* Constant right *)
      apply BipoleReasoning in H3...
      -
      apply checkEncodeCasesU in H8... 
      apply OLInPermutation' in H5...
      rewrite H5...
      rewrite <- perm_takeit_2...
      -
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9.
      rewrite app_assoc in H9.
      rewrite <- LEncodeApp in H9.
      symmetry in H9.
      apply checkEncodeCasesU in H9... 
      apply OLInPermutation' in H5...
      rewrite H5...
      rewrite <- app_comm_cons...
  ++ (* Constant left *)
      apply BipoleReasoning in H3...
      -
      simpl in H7.
      inversion H7... 
      -
      simpl in H7.
      inversion H7... 
  ++ (* Constant left *)
      apply BipoleReasoning in H3...
      -
      simpl in H7.
      inversion H7... 
      -
      simpl in H7.
      inversion H7...  
  ++ (* Constant right *)
      apply BipoleReasoning in H3...
      -
      apply checkEncodeCasesD in H8... 
      apply OLInPermutationL' in H5...
      rewrite H5...
      rewrite <- perm_takeit_2...
      -
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9.
      rewrite app_assoc in H9.
      rewrite <- LEncodeApp in H9.
      symmetry in H9.
      apply checkEncodeCasesD in H9... 
      apply OLInPermutationL' in H5...
      checkPermutationCases H5.
      1-2: rewrite H5...
      2: rewrite <- app_comm_cons...
      decideT.
  + inversion H0... 
    ++ (* binary connective right *)
      apply BipoleReasoning in H3...
      -
      apply checkEncodeCasesU in H8...
      apply OLInPermutation' in H5...
        rewrite H5 in HisR2.
        rewrite H5...
        rewrite <- perm_takeit_2...
        
      apply FocusingWith in H7...
      apply KT4AndR...
      
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x2)...
      LLExact H9.
      rewrite <- H6...
        
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x2)...
      LLExact H10.
      rewrite <- H6...
      -
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9.
      rewrite app_assoc in H9.
      rewrite <- LEncodeApp in H9.
      symmetry in H9.
    
      apply checkEncodeCasesU in H9...
      apply OLInPermutation' in H5...
        rewrite H5 in HisR1.
        rewrite H5...
      rewrite <- app_comm_cons.  
      apply KT4CtR.  
      rewrite app_comm_cons. 
        rewrite <- H5...
      
      apply FocusingWith in H7...
      apply KT4AndR...
      
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x3)...
      simpl...
      LLExact H10.
      
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x3)...
      simpl...
      LLExact H11.
    ++ 
      apply BipoleReasoning in H3...      
      -
      apply checkEncodeCasesD in H8...
      apply OLInPermutationL' in H5...
        rewrite H5 in HisL2.
        rewrite H5...
        rewrite <- perm_takeit_2...
        
      apply FocusingPlus in H7...
      apply KT4AndL1...
      
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x2)...
      LLExact H8.
      rewrite <- H6...
      
      apply KT4AndL2...       
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x2)...
      LLExact H8.
      rewrite <- H6...
      -
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9.
      rewrite app_assoc in H9.
      rewrite <- LEncodeApp in H9.
      symmetry in H9.
    
      apply checkEncodeCasesD in H9...
      apply OLInPermutationL' in H5...
      checkPermutationCases H5.
        rewrite H5 in HisD.
        rewrite H5...
        decideT.
        rewrite <- H5.
     
      apply FocusingPlus in H7...
      apply KT4AndL1...
      
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x4)...
      
      apply KT4AndL2...
      
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x4)...
      
      rewrite H5.
      
      rewrite <- app_comm_cons.  
      apply KT4CtL.  
      rewrite app_comm_cons. 
        rewrite <- H5...
      
      apply FocusingPlus in H7...
      apply KT4AndL1...
      
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x4)...
      
      apply KT4AndL2...
      
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x4)...
    ++ 
      apply BipoleReasoning in H3...      
      -
      apply checkEncodeCasesU in H8...
      apply OLInPermutation' in H5...
        rewrite H5 in HisR2.
        rewrite H5...
        rewrite <- perm_takeit_2...
        
      apply FocusingPlus in H7...
      apply KT4OrR1...
      
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x2)...
      LLExact H8.
      rewrite <- H6...
      
      apply KT4OrR2...       
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x2)...
      LLExact H8.
      rewrite <- H6...
      -
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9.
      rewrite app_assoc in H9.
      rewrite <- LEncodeApp in H9.
      symmetry in H9.
    
      apply checkEncodeCasesU in H9...
      apply OLInPermutation' in H5...
      
      rewrite H5.
      
      rewrite <- app_comm_cons.  
      apply KT4CtR.  
      rewrite app_comm_cons. 
        rewrite <- H5...
      
      apply FocusingPlus in H7...
      apply KT4OrR1...
      
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x3)...
      simpl...
      LLExact H9.
      
      apply KT4OrR2...
      
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x3)...
      simpl...
      LLExact H9.
    ++ 
      apply BipoleReasoning in H3...
      -
      apply checkEncodeCasesD in H8...
      apply OLInPermutationL' in H5...
        rewrite H5 in HisL2.
        rewrite H5...
        rewrite <- perm_takeit_2...
        
      apply FocusingWith in H7...
      apply KT4OrL...
      
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x2)...
      LLExact H9.
      rewrite <- H6...
        
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x2)...
      LLExact H10.
      rewrite <- H6...
      -
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9.
      rewrite app_assoc in H9.
      rewrite <- LEncodeApp in H9.
      symmetry in H9.
    
      apply checkEncodeCasesD in H9...
      apply OLInPermutationL' in H5...
      checkPermutationCases H5.
       
      rewrite H5 in HisD.
      rewrite H5. decideT. 
        rewrite <- H5...
      
       apply FocusingWith in H7...
      apply KT4OrL...
      
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x4)...
      
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x4)...
      
      rewrite H5 in HisL1.
      rewrite H5.
      rewrite <- app_comm_cons.  
      apply KT4CtL.  
      rewrite app_comm_cons. 
        rewrite <- H5...
       apply FocusingWith in H7...
      apply KT4OrL...
      
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x4)...
      
      rewrite perm_takeit_2...
      eapply H with (j:=j) (m:=x4)...
  + apply FocusingInitRuleU in H3;sauto.
    ++   
      rewrite Permutation_cons_append in H4.
      apply destructEncode in H4...
      all: try repeat match goal with
      | [H: REncode _ = nil |- _] => apply map_eq_nil in H;sauto
      | [H: LEncode _ = nil |- _] => apply map_eq_nil in H;sauto
      | [H: REncode _ = [_] |- _] => apply map_eq_cons in H;sauto
      | [H: LEncode _ = [_] |- _] => apply map_eq_cons in H;sauto
      end... 
      inversion H9; inversion H7...
      rewrite Permutation_app_comm.
      simpl...
      rewrite Permutation_app_comm. 
      simpl...
    ++ 
        all: try repeat match goal with
      | [H: REncode _ = nil |- _] => apply map_eq_nil in H;sauto
      | [H: LEncode _ = nil |- _] => apply map_eq_nil in H;sauto
      | [H: REncode _ = [_] |- _] => apply map_eq_cons in H;sauto
      | [H: LEncode _ = [_] |- _] => apply map_eq_cons in H;sauto
      end...
      
      inversion H8...
      rewrite Permutation_app_comm. 
      simpl...
    
      apply PermSecond in H6.
      rewrite !secondApp in H6.
      rewrite !secCEncode in H6.
      simpl in H6.
      rewrite app_assoc in H6.
      rewrite <- LEncodeApp in H6.
      symmetry in H6.
    
      apply checkEncodeCasesD in H6...
      apply OLInPermutationL' in H4...
      checkPermutationCases H4.
       
      rewrite H4.
      decideT.
      rewrite H4...
    ++ apply map_eq_cons in H5... 
    ++ apply map_eq_cons in H8...
    ++  
        all: try repeat match goal with
      | [H: REncode _ = nil |- _] => apply map_eq_nil in H;sauto
      | [H: LEncode _ = nil |- _] => apply map_eq_nil in H;sauto
      | [H: REncode _ = [_] |- _] => apply map_eq_cons in H;sauto
      | [H: LEncode _ = [_] |- _] => apply map_eq_cons in H;sauto
      end...
      
      inversion H8...
      rewrite Permutation_app_comm. 
      simpl...
    
      apply PermSecond in H6.
      rewrite !secondApp in H6.
      rewrite !secCEncode in H6.
      simpl in H6.
      rewrite app_assoc in H6.
      rewrite <- LEncodeApp in H6.
      symmetry in H6.
    
      apply checkEncodeCasesU in H6...
      apply OLInPermutation' in H4...
      rewrite H4...
     ++ 
    
      apply PermSecond in H4, H6.
      rewrite !secondApp in H4, H6.
      rewrite !secCEncode in H4, H6.
      simpl in H4, H6.
      rewrite app_assoc in H4, H6.
      rewrite <- LEncodeApp in H4, H6.
      symmetry in H4, H6.
    
      apply checkEncodeCasesD in H4...
      apply checkEncodeCasesU in H6...
      apply OLInPermutationL' in H9...
      apply OLInPermutation' in H6...
      rewrite H6...
      checkPermutationCases H9.
     
     
        all: try repeat match goal with
      | [H: REncode _ = nil |- _] => apply map_eq_nil in H;sauto
      | [H: LEncode _ = nil |- _] => apply map_eq_nil in H;sauto
      | [H: REncode _ = [_] |- _] => apply map_eq_cons in H;sauto
      | [H: LEncode _ = [_] |- _] => apply map_eq_cons in H;sauto
      end...
     
      rewrite H9. decideT. 
      rewrite H9...
    + inversion H0... 
    ++ apply BipoleReasoning in H3...
      -
      apply checkEncodeCasesU in H8...
      apply OLInPermutation' in H4...
        rewrite H4 in HisR2.
        rewrite H4...
        rewrite <- perm_takeit_2...
       rewrite <- CEncodeApp in H7.
       rewrite <- LocCEncodeLoc in H7.
       simpl in H7. 
       rewrite Permutation_app_comm in H7.
       apply FocusingBangSet in H7...
       apply map_eq_nil in H3...
       apply map_eq_nil in H5...
       
        apply KT4BoxR.
        apply destructCEncode in H9...
        apply destructLEncode in H9...
       
        eapply ImpGen with (A1:=x1) (A2:=[]) (A3:=x5)...
         change (@nil uexp) with ( (@nil uexp)++[]).
         rewrite app_comm_cons.
        eapply H with (m:=x2) (j:=j)...
        simpl...
        Import SL.InvPositivePhase.
        rewrite Permutation_app_comm.
        simpl...
        apply AbsorptionL;solveSignature1...
        LLExact H14.
        rewrite H4.
        srewrite H5... 
      -
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9.
      rewrite app_assoc in H9.
      rewrite <- LEncodeApp in H9.
      symmetry in H9.
    
      apply checkEncodeCasesU in H9...
      apply OLInPermutation' in H4...
    
        rewrite H4 in HisR1.
        rewrite H4...
        rewrite <- app_comm_cons. 
       rewrite <- CEncodeApp in H7.
       rewrite <- LocCEncodeLoc in H7.
       simpl in H7. 
       rewrite Permutation_app_comm in H7.
       apply FocusingBangSet in H7...
       apply map_eq_nil in H3, H13...
       
        apply destructCEncode in H10...
        apply destructLEncode in H14...
        apply KT4BoxR.
        eapply ImpGen with (A1:=x7) (A2:=[]) (A3:=x8)...
         change (@nil uexp) with ( (@nil uexp)++[]).
         rewrite app_comm_cons.
        eapply H with (m:=x3) (j:=j)...
        simpl...
        Import SL.InvPositivePhase.
        rewrite Permutation_app_comm.
        simpl...
        apply AbsorptionL;solveSignature1...
        LLExact H15.
        rewrite H7.
        srewrite H10...
    ++ apply BipoleReasoning in H3...
      -
      apply checkEncodeCasesD in H8...
      apply OLInPermutationL' in H4...
        rewrite H4 in HisL2.
        rewrite H4...
        rewrite <- perm_takeit_2...
        apply FocusingQuest in H7...
        apply KT4BoxL.
        eapply H with (m:=x2) (j:=j)...
        LLExact H8.
      -  
      apply PermSecond in H9.
      rewrite !secondApp in H9.
      rewrite !secCEncode in H9.
      simpl in H9.
      rewrite app_assoc in H9.
      rewrite <- LEncodeApp in H9.
      symmetry in H9.
    
      apply checkEncodeCasesD in H9...
      apply OLInPermutationL' in H4...
      checkPermutationCases H4.
       
      rewrite H4 in HisD.
      rewrite H4. decideT. 
        rewrite <- H4...
      
       apply FocusingQuest in H7...
       apply KT4BoxL.
        eapply H with (m:=x4) (j:=j)...
      
      rewrite H4. 
      rewrite <- app_comm_cons.  
      apply KT4CtL.  
      rewrite app_comm_cons. 
        rewrite <- H4...
      
      apply FocusingQuest in H7...
       apply KT4BoxL.
        eapply H with (m:=x4) (j:=j)...
    +
       apply BipoleReasoning in H3...
    ++
        apply FocusingQuest in H6...
        apply checkEncodeCasesD in H7... 
        apply OLInPermutationL' in H4...
        rewrite H4.
        rewrite <- Permutation_middle.
        rewrite app_comm_cons.
        eapply H with (m:=x1) (j:=j)...
        LLExact H5. simpl...
    ++
        apply FocusingQuest in H6...
       
        apply PermSecond in H8.
      rewrite !secondApp in H8.
      rewrite !secCEncode in H8.
      simpl in H8.
      rewrite app_assoc in H8.
      rewrite <- LEncodeApp in H8.
      symmetry in H8.
    
      apply checkEncodeCasesD in H8...
      apply OLInPermutationL' in H4...
      checkPermutationCases H4.
       
      rewrite H4 in HisD.
      rewrite H4. decideT. 
        rewrite <- H4...
      rewrite app_comm_cons.
       eapply H with (m:=x2) (j:=j)...
       LLExact H6. simpl...
      
      rewrite H4. 
        rewrite <- app_comm_cons.
        apply KT4CtL.
        rewrite app_comm_cons.
        rewrite <- H4.
        rewrite app_comm_cons.
        eapply H with (m:=x2) (j:=j)...
        LLExact H6. simpl...
    +
       apply BipoleReasoning in H3...
    ++
        apply FocusingQuest in H6...
        apply checkEncodeCasesU in H7... 
        apply OLInPermutation' in H4...
        rewrite H4.
        rewrite <- Permutation_middle.
        rewrite app_comm_cons.
        eapply H with (m:=x1) (j:=j)...
        LLExact H5. simpl...
    ++
        apply FocusingQuest in H6...
       
        apply PermSecond in H8.
      rewrite !secondApp in H8.
      rewrite !secCEncode in H8.
      simpl in H8.
      rewrite app_assoc in H8.
      rewrite <- LEncodeApp in H8.
      symmetry in H8.
    
      apply checkEncodeCasesU in H8...
      apply OLInPermutation' in H4...
      
      rewrite H4. 
        rewrite <- app_comm_cons.
        apply KT4CtR.
        rewrite app_comm_cons.
        rewrite <- H4.
        rewrite app_comm_cons.
        eapply H with (m:=x2) (j:=j)...
        LLExact H6. simpl...
  * solveSignature1.
Qed.

  Lemma  SoundenessKT4' j D L1 R1 L2 R2 :
     mt j = true -> m4 j = true ->
      isOLFormulaL D ->
      isOLFormulaL L1 ->
      isOLFormulaL R1 ->
      isOLFormulaL L2 ->
      isOLFormulaL R2 ->
      KT4Seq D (L1++L2) (R1++R2) ->
      seq (KT4 j) 
     (CEncode j (LEncode D) ++ (CEncode loc (LEncode L1) ++ CEncode loc (REncode R1))) (LEncode L2 ++ REncode R2) (UP []).
 Proof with OLSolve.
 
 intros Mt Ft isFD isFL1 isFR1 isFL2 isFR2 Hyp.
 eapply PosNegSetT with (a:=loc) (b:=loc)...
  1-2: intro; intros...
  eapply SoundenessKT4 with (j:=j) in Hyp...
  eapply exchangeCC'.
  2:{ exact Hyp. }
  rewrite LEncodeApp.
  rewrite REncodeApp.
  rewrite !CEncodeApp... perm.
  Qed.     
     

 Theorem AdequacyKT4 j D L1 R1 L2 R2: 
   mt j = true -> m4 j = true ->
      isOLFormulaL D ->
      isOLFormulaL L1 ->
      isOLFormulaL R1 ->
      isOLFormulaL L2 ->
      isOLFormulaL R2 ->
   KT4Seq D (L1 ++ L2) (R1 ++ R2) <->
   seq (KT4 j) 
     (CEncode j (LEncode D) ++ (CEncode loc (LEncode L1) ++ CEncode loc (REncode R1))) (LEncode L2 ++ REncode R2) (UP []).  
Proof with sauto. 
 intros.
  split;intros.
  + apply SoundenessKT4'... 
  + apply seqtoSeqN in H6... 
    apply Completeness in H6...
Qed.

End KT4Adequacy.


