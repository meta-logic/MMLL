(** * System LK for classical logic encoded as an LL theory

This file encodes the inference rules of the system LK. Since the
rules used are cut-coherent, the cut-elimination theorem applies for
this system.
 *)

Require Import MMLL.OL.CutCoherence.OLTactics.
Require Import MMLL.OL.CutCoherence.OLPosNeg.
Require Import MMLL.OL.CutCoherence.Bipoles.
Require Import MMLL.SL.CutElimination.
Require Import MMLL.SL.FLLTactics.
Require Import Coq.Init.Nat.
Require Import MMLL.Misc.Permutations.

Export ListNotations.
Export LLNotations.
Set Implicit Arguments.

Section KT4Adequacy.
Context {SI : Signature}.
Context {USI : UnbSignature}.
Context {USInoD : UnbNoDSignature}. 

(** ** Syntax *)
(** units: true and false *)
Inductive Constants := TT | FF  .
(** conjunction, disjunction and implication *)
Inductive Connectives := AND | OR | IMP  .
(** universal and existential quantifiers *)
Inductive Quantifiers := ALL|SOME .

Inductive UConnectives := BOX.


Instance SimpleOLSig : OLSyntax:=
  {|
    OLType := nat;
    constants := Constants ;
    uconnectives := UConnectives;
    connectives := Connectives ;
    quantifiers := Quantifiers
  |}.

(**  Constants *)
Definition rulesCTE (c:constants) :=
  match c with
  | TT => ZEROTOP
  | FF => TOPZERO
  end.

(**  Binary connectives *)
Definition rulesBC (c :connectives) :=
  match c with
  | AND => PARTENSOR
  | OR =>  TENSORPAR
  | IMP => TENSORPAREXCH
  end.

(**  Unary connectives *)
Definition rulesUC (c :uconnectives) :=
  match c with
  | BOX => QUESTBANG
  end.
  
(**  Quantifiers *)
Definition rulesQD (q :quantifiers) :=
  match q with
  | ALL => ALLSOME
  | SOME => SOMEALL
  end
.

Instance SimpleOORUles : OORules :=
  {|
    rulesCte := rulesCTE ;
    rulesBin := rulesBC;
    rulesU := rulesUC;
    rulesQ := rulesQD
  |}.


(** An inductive definition for KT4. This will be used to prove that
the LL encoding is sound and complete *)

Inductive KT4Seq : list uexp -> list uexp -> list uexp -> Prop :=
| KT4TRUE : forall D L L', KT4Seq D L ((t_cons TT)::L')
| KT4FALSE : forall D L L', KT4Seq D (t_cons FF :: L) L' 
| KT4init : forall D L L' F,  KT4Seq D (F:: L) (F::L')

| KT4AndL1 : forall D L F G L', KT4Seq D (F :: L) L' -> KT4Seq D ( (t_bin AND F G) :: L) L'
| KT4AndL2 : forall D L F G L', KT4Seq D (G :: L) L' -> KT4Seq D ( (t_bin AND F G) :: L) L'
| KT4AndR : forall D L F G L', KT4Seq D L (F::L') -> KT4Seq D L (G::L') -> KT4Seq D L (t_bin AND F G :: L')

| KT4OrL : forall D L F G L',  KT4Seq D (F :: L) L' -> KT4Seq D (G :: L) L' -> KT4Seq D ( (t_bin OR F G) :: L) L'
| KT4OrR1 : forall D L F G L', KT4Seq D L (F::L') -> KT4Seq D L (t_bin OR F G :: L')
| KT4OrR2 : forall D L F G L', KT4Seq D L (G::L') -> KT4Seq D L (t_bin OR F G :: L')
 
| KT4ImpL : forall A B D L1 L2 L1' L2', KT4Seq D L1 (A::L1') -> KT4Seq D (B:: L2) L2' -> KT4Seq D (t_bin IMP A B ::L1++L2) (L1'++L2')
| KT4ImpR : forall L A B D L', KT4Seq D (A:: L) (B::L') ->  KT4Seq D L (t_bin IMP A B :: L')             
 
 (* Explicit exchange *)
| KT4ExL : forall D L L' Delta, Permutation L L' -> KT4Seq D L Delta -> KT4Seq D L' Delta
| KT4ExR : forall D L L' Delta, Permutation L L' -> KT4Seq D Delta L -> KT4Seq D Delta L'
(* Explicit contraction *)
| KT4CtL : forall D L L' F, KT4Seq D (F :: F :: L)  L' -> KT4Seq D (F :: L)  L'
| KT4CtR : forall D L L' F, KT4Seq D L (F :: F :: L')   -> KT4Seq D L (F :: L')

| KT4WkL : forall D L L' F, KT4Seq D L L' -> KT4Seq D (F :: L)  L'
| KT4WkR : forall D L L' F, KT4Seq D L L' -> KT4Seq D L (F :: L')

| KT4Dec : forall D L L' F, In F D  -> KT4Seq D (F::L) L' ->  KT4Seq D L L'

| KT4BoxL : forall D L F L', KT4Seq (F::D) L L' ->  KT4Seq D (t_ucon BOX F :: L) L'

| KT4BoxR : forall D L F L', KT4SeqT D L [ ] [ ] [F] ->  KT4Seq D L (t_ucon BOX F :: L')
    with
      KT4SeqT : list uexp -> list uexp -> list uexp -> list uexp -> list uexp -> Prop :=
       | KT4_K: forall F A A' B D L R, Remove F A A' -> KT4SeqT A' B D (F::L) R ->  KT4SeqT A B D L R                                 
       | KT4_4: forall F A A' B D L R, Remove F A A' -> KT4SeqT A' B (F::D) L R -> KT4SeqT A B D L R                                
       | KT4Release : forall A B D L R, KT4Seq D L R -> KT4SeqT A B D L R
.

 Notation "D ';' L '|--' R " := (KT4Seq D L R)  (at level 80).
 Notation "A ';' B '//' D ';' L '|--' R " := (KT4SeqT A B D L R)  (at level 80).
   
Hint Constructors KT4Seq : core .
Hint Constructors KT4SeqT : core .

Inductive KT4Seq' : list uexp -> list uexp -> Prop :=
| KT4TRUE' : forall L L', KT4Seq' L ((t_cons TT)::L')
| KT4FALSE' : forall L L', KT4Seq' (t_cons FF :: L) L' 
| KT4init' : forall L L' F,  KT4Seq' (F:: L) (F::L')

| KT4AndL1' : forall L F G L', KT4Seq' (F :: L) L' -> KT4Seq' ( (t_bin AND F G) :: L) L'
| KT4AndL2' : forall L F G L', KT4Seq' (G :: L) L' -> KT4Seq' ( (t_bin AND F G) :: L) L'
| KT4AndR' : forall L F G L', KT4Seq' L (F::L') -> KT4Seq' L (G::L') -> KT4Seq' L (t_bin AND F G :: L')

| KT4OrL' : forall L F G L',  KT4Seq' (F :: L) L' -> KT4Seq' (G :: L) L' -> KT4Seq' ( (t_bin OR F G) :: L) L'
| KT4OrR1' : forall L F G L', KT4Seq' L (F::L') -> KT4Seq' L (t_bin OR F G :: L')
| KT4OrR2' : forall L F G L', KT4Seq' L (G::L') -> KT4Seq' L (t_bin OR F G :: L')
 
| KT4ImpL' : forall A B L1 L2 L1' L2', KT4Seq' L1 (A::L1') -> KT4Seq' (B:: L2) L2' -> KT4Seq' (t_bin IMP A B ::L1++L2) (L1'++L2')
| KT4ImpR' : forall L A B L', KT4Seq' (A:: L) (B::L') ->  KT4Seq' L (t_bin IMP A B :: L')
                 
| KT4ExL' : forall L L' Delta, Permutation L L' -> KT4Seq' L Delta -> KT4Seq' L' Delta
| KT4ExR' : forall L L' Delta, Permutation L L' -> KT4Seq' Delta L -> KT4Seq' Delta L'
(* Explicit contraction *)
| KT4CtL' : forall L L' F, KT4Seq' (F :: F :: L)  L' -> KT4Seq' (F :: L)  L'
| KT4CtR' : forall L L' F, KT4Seq' L (F :: F :: L')   -> KT4Seq' L (F :: L')

| KT4WkL' : forall L L' F, KT4Seq' L L' -> KT4Seq' (F :: L)  L'
| KT4WkR' : forall L L' F, KT4Seq' L L' -> KT4Seq' L (F :: L')

| KT4BoxL' : forall L F L', KT4Seq' (F :: L) L' ->  KT4Seq' (t_ucon BOX F :: L) L'

| KT4BoxR' : forall L F L', KT4SeqT' L [ ] [F] ->  KT4Seq' L (t_ucon BOX F :: L')
    with
      KT4SeqT' : list uexp -> list uexp -> list uexp -> Prop :=
       | KT4_K' : forall L F L' D D' , Remove (t_ucon BOX F) D D' -> KT4SeqT' D' (F::L) L' ->  KT4SeqT' D L L'                                  
       | KT4_4' : forall L F L' D D' , Remove (t_ucon BOX F) D D' -> KT4SeqT' D' (t_ucon BOX F::L) L' ->  KT4SeqT' D L L'                                  
       | KT4Release' : forall L L' T, KT4Seq' L L' -> KT4SeqT' T L L'
.

Hint Constructors KT4Seq' : core .
Hint Constructors KT4SeqT' : core .

Theorem KT4CtLGen'  C : forall L L', KT4Seq' (L++C++C)  L' -> KT4Seq' (L++C) L'.
Proof with sauto.
  induction C;intros...
  eapply KT4ExL' with (L:=a::L++C)...
  apply KT4CtL'.
  eapply KT4ExL' with (L:=(a::a::L)++C)...
  eapply IHC.
  eapply KT4ExL' with (L:=(L ++ (a :: C) ++ a :: C))...
Qed.

  Theorem KT4SeqPerm1' D1  : forall D2 L R ,
  Permutation D1 D2 -> KT4SeqT' D2 L R -> KT4SeqT' D1 L R .
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent D1.
  induction Hseq;intros;eauto using Permutation_in.
  symmetry in Hp.
  generalize (Remove_Permutation_Ex2 H Hp);intros...
  eapply KT4_K' with (F:=F) (D':=x)...
  symmetry in Hp.
  generalize (Remove_Permutation_Ex2 H Hp);intros...
  eapply KT4_4' with (F:=F) (D':=x)...
  Qed.
  
  Theorem KT4SeqPerm2' L1  : forall D L2 R,
  Permutation L1 L2 -> KT4SeqT' D L2 R -> KT4SeqT' D L1 R .
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent L1.
  induction Hseq;intros;eauto using Permutation_in.
  apply KT4Release'...
  eapply KT4ExL'.
  exact (symmetry Hp).
  auto.
  Qed.

  Theorem KT4SeqPerm3' R1  : forall D L R2,
  Permutation R1 R2 -> KT4SeqT' D L R2 -> KT4SeqT' D L R1.
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent R1.
  induction Hseq;intros;eauto using Permutation_in.
  apply KT4Release'...
  eapply KT4ExR'.
  exact (symmetry Hp).
  auto.
  Qed.
      
  Global Instance KT4T_morph' : 
  Proper ((@Permutation uexp) ==> (@Permutation uexp) ==>  (@Permutation uexp)  ==> iff) (KT4SeqT').
Proof.
  unfold Proper; unfold respectful. 
  intros.
  split;intros;subst.
  - symmetry in H.
    symmetry in H0.
    symmetry in H1.
    eapply KT4SeqPerm1';eauto.
    eapply KT4SeqPerm2';eauto.
    eapply KT4SeqPerm3';eauto.
  - eapply KT4SeqPerm1';eauto.
    eapply KT4SeqPerm2';eauto.
    eapply KT4SeqPerm3';eauto.
Qed.


  Global Instance KT4_morph' : 
  Proper ((@Permutation uexp) ==> (@Permutation uexp) ==> iff) (KT4Seq').
Proof with auto.
  unfold Proper; unfold respectful. 
  intros.
  split;intros.
  eapply (KT4ExL' H).  
  eapply (KT4ExR' H0)... 
  eapply (KT4ExL' (symmetry H)).  
  eapply (KT4ExR' (symmetry H0))... 
Qed.

 Theorem KT4SeqTWkL' D : forall F L R, KT4SeqT' D L R -> KT4SeqT' (F::D) L R .
  Proof with  CleanContext.
   intros.
   induction H;intros...
     apply Remove_Permute in H...
     rewrite H.
     rewrite perm_swap.
     apply KT4_K' with (F:=F0) (D':=F::D')...
apply Remove_Permute in H...
     rewrite H.
     rewrite perm_swap.
     apply KT4_4' with (F:=F0) (D':=F::D')...
 Qed.
 
 Theorem KT4SeqTWkLGen' C : forall D L R, KT4SeqT' D L R -> KT4SeqT' (C++D) L R.
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply KT4SeqTWkL'...
Qed.

Definition toBox D:= map (fun x => t_ucon BOX x) D.

  Theorem KT4SeqPerm1 A1  : forall A2 L R B D,
  Permutation A1 A2 -> KT4SeqT A2 B D L R -> KT4SeqT A1 B D L R .
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent A1.
  induction Hseq;intros;eauto using Permutation_in.
  symmetry in Hp.
  generalize (Remove_Permutation_Ex2 H Hp);intros...
   eapply KT4_K with (F:=F) (A':=x)...
   
  symmetry in Hp.
  generalize (Remove_Permutation_Ex2 H Hp);intros...
   eapply KT4_4 with (F:=F) (A':=x)...  
   
  Qed.
  
   Theorem KT4SeqPerm2 B1  : forall B2 L R A D,
  Permutation B1 B2 -> KT4SeqT A B2 D L R -> KT4SeqT A B1 D L R .
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent B1.
  induction Hseq;intros;eauto using Permutation_in.
  Qed.

  
  Theorem KT4SeqPerm4 L1  : forall L2 R A B D,
  Permutation L1 L2 -> KT4SeqT A B D L2 R -> KT4SeqT A B D L1 R .
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent L1.
  induction Hseq;intros;eauto using Permutation_in.
  apply KT4Release...
  eapply KT4ExL.
  exact (symmetry Hp).
  auto.
  Qed.

  Theorem KT4SeqPerm5 R1  : forall L R2 A B D,
  Permutation R1 R2 -> KT4SeqT A B D L R2 -> KT4SeqT A B D L R1.
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent R1.
  induction Hseq;intros;eauto using Permutation_in.
  apply KT4Release...
  eapply KT4ExR.
  exact (symmetry Hp).
  auto.
  Qed.
  
 Theorem KT4SeqPerm D1  : forall D2 L R,
  Permutation D1 D2 -> KT4Seq D2 L R -> KT4Seq D1 L R .
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent D1.
  induction Hseq;intros;eauto using Permutation_in.
  
  eapply KT4Dec with (F:=F)... 
  rewrite Hp...
  
  apply KT4BoxR.
  eapply KT4SeqPerm1 with (A2:=D)...
  Qed.
   
    
  Theorem KT4SeqPerm3 D1  : forall D2 L R A B,
  Permutation D1 D2 -> KT4SeqT A B D2 L R -> KT4SeqT A B D1 L R .
  Proof with  CleanContext.
   intros *.
  intros Hp Hseq.
  generalize dependent D1.
  induction Hseq;intros;eauto using Permutation_in.
  apply KT4Release...
  eapply KT4SeqPerm;eauto.
  Qed. 
  
    
  Global Instance KT4T_morph : 
  Proper ((@Permutation uexp) ==> (@Permutation uexp) ==>  (@Permutation uexp) ==> (@Permutation uexp) ==>  (@Permutation uexp)  ==> iff) (KT4SeqT).
Proof.
  unfold Proper; unfold respectful. 
  intros.
  split;intros;subst.
  - symmetry in H.
    symmetry in H0.
    symmetry in H1.
    symmetry in H2.
    symmetry in H3.
    eapply KT4SeqPerm1;eauto.
    eapply KT4SeqPerm2;eauto.
    eapply KT4SeqPerm3;eauto.
    eapply KT4SeqPerm4;eauto.
    eapply KT4SeqPerm5;eauto.
  - eapply KT4SeqPerm1;eauto.
    eapply KT4SeqPerm2;eauto.
    eapply KT4SeqPerm3;eauto.
    eapply KT4SeqPerm4;eauto.
    eapply KT4SeqPerm5;eauto.
Qed.

  Global Instance KT4_morph : 
  Proper ((@Permutation uexp) ==> (@Permutation uexp) ==> (@Permutation uexp) ==> iff) (KT4Seq).
Proof.
  unfold Proper; unfold respectful. 
  intros.
  split;intros;subst.
  1: eapply KT4SeqPerm with (D2:=x);eauto.
  symmetry in H0. 
  symmetry in H1.
  eapply KT4SeqPerm with (D2:=y);eauto.
Qed.

  Theorem KT4SeqTWkL : forall F L R A B D, KT4SeqT A B D L R -> KT4SeqT A B D (F::L) R .
  Proof with  CleanContext.
   intros.
   induction H;intros...
     apply Remove_Permute in H...
     rewrite H.
     eapply KT4_K with (F:=F0) (A':=A')...
     rewrite perm_swap...
     
     apply Remove_Permute in H...
     rewrite H.
     eapply KT4_4 with (F:=F0) (A':=A')...
  Qed. 
 
  Theorem KT4SeqTWkR : forall F L R A B D, KT4SeqT A B D L R -> KT4SeqT A B D L (F::R) .
  Proof with  CleanContext.
   intros.
   induction H;intros...
     apply Remove_Permute in H...
     rewrite H.
     eapply KT4_K with (F:=F0) (A':=A')...
      apply Remove_Permute in H...
     rewrite H.
     eapply KT4_4 with (F:=F0) (A':=A')...
 Qed.
  
  Theorem KT4SeqTWkL1 : forall F L R A B D, KT4SeqT A B D L R -> KT4SeqT (F::A) B D L R .
  Proof with  CleanContext.
   intros.
   induction H;intros...
     apply Remove_Permute in H...
     rewrite H.
     rewrite perm_swap.
      eapply KT4_K with (F:=F0) (A':=F::A')...
    apply Remove_Permute in H...
     rewrite H.
     rewrite perm_swap.
      eapply KT4_4 with (F:=F0) (A':=F::A')... 
 Qed.
 
   Theorem KT4SeqTWkL2 : forall F L R A B D, KT4SeqT A B D L R -> KT4SeqT A (F::B) D L R .
  Proof with  CleanContext.
   intros.
   induction H;intros...
     apply Remove_Permute in H...
     rewrite H.
      eapply KT4_K with (F:=F0) (A':=A')...
    apply Remove_Permute in H...
     rewrite H.
      eapply KT4_4 with (F:=F0) (A':=A')... 
 Qed.
 
 Theorem KT4SeqWkL' D : forall F L R, KT4Seq D L R -> KT4Seq (F::D) L R .
  Proof with  CleanContext.
   intros.
   induction H;intros...
   rewrite <- H...
   rewrite <- H...
    apply InPermutation in H...
     rewrite H.
     rewrite perm_swap.
     eapply KT4Dec with (F:=F0)...
     rewrite perm_swap...
     rewrite <- H...
     apply KT4BoxL.
     rewrite perm_swap...
     apply KT4BoxR.
     apply KT4SeqTWkL1...
 Qed.

   Theorem KT4SeqTWkL3 : forall F L R A B D, KT4SeqT A B D L R -> KT4SeqT A B (F::D) L R .
  Proof with  CleanContext.
   intros.
   induction H;intros...
     apply Remove_Permute in H...
     rewrite H.
      eapply KT4_K with (F:=F0) (A':=A')...
    apply Remove_Permute in H...
     rewrite H.
      eapply KT4_4 with (F:=F0) (A':=A')... 
      rewrite perm_swap...
    apply KT4Release...
    apply KT4SeqWkL'...  
 Qed.
 
 
 Theorem ImpGenInv A B D L R: 
    KT4SeqT A B D L R ->
    exists A1 A2 A3, Permutation A (A1++A2++A3) /\ KT4Seq (D++A1) (L++A2) R.
  Proof with  CleanContext.
   intros.
   induction H;intros...
   - apply Remove_Permute in H...
     eexists x.
     exists (F::x0).
     exists x1.
     split...
     rewrite H.
     rewrite H2...
     rewrite <- Permutation_middle...
   - apply Remove_Permute in H...
     eexists (F::x).
     exists x0.
     eexists x1.
     split...
     rewrite <- Permutation_middle...
   - exists [].
     exists [].
     exists A.
     split...
 Qed.    
 

 Theorem ImpGen A : forall D A1 A2 A3 B L R, 
    Permutation A (A1++A2++A3) -> KT4Seq (D++A1) (L++A2) R ->
    KT4SeqT A B D L R.  
  Proof with  CleanContext.
   induction A;intros...
   checkPermutationCases H.
   - rewrite H1 in H0.
     rewrite <- Permutation_middle in H0.
     rewrite app_comm_cons in H0.
     eapply IHA with (B:=B) (A3:=A3) in H0...
     apply KT4_4 with (F:=a) (A':=A)...
   - checkPermutationCases H1.
     + rewrite H1 in H0.
       rewrite <- Permutation_middle in H0.
       rewrite app_comm_cons in H0.
       eapply IHA with (B:=B) (A3:=A3) in H0...
       apply KT4_K with (F:=a) (A':=A)...
       rewrite <- H2.
       rewrite <- H3...
     + apply KT4SeqTWkL1...
       eapply IHA with (A1:=A1) (A2:=A2) (A3:=x0)... 
       rewrite <- H2.
       rewrite <- H3...
 Qed.    
    

  
Theorem KT4CtLGen C : forall D L L', KT4Seq D (C ++ C ++ L)  L' -> KT4Seq D (C ++ L) L'.
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply KT4CtL.
  rewrite Permutation_cons_append.
  rewrite Permutation_cons_append.
  do 2 rewrite app_assoc_reverse.
  eapply IHC.
  assert(Hs: Permutation (C ++ C ++ L ++ [a] ++ [a]) ((a :: C) ++ (a :: C) ++ L)) by perm.
  rewrite Hs...
Qed.


Theorem KT4CtRGen D C : forall L L', KT4Seq D L (C ++ C ++ L') -> KT4Seq D L (C ++ L').
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply KT4CtR.
  rewrite Permutation_cons_append.
  rewrite Permutation_cons_append.
  do 2 rewrite app_assoc_reverse.
  eapply IHC.
  assert(Hs: Permutation (C ++ C ++ L' ++ [a] ++ [a]) ((a :: C) ++ (a :: C) ++ L')) by perm.
  rewrite Hs...
Qed.

Theorem KT4WkLGen C : forall D L L', KT4Seq D L  L' -> KT4Seq D (C ++ L) L'.
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply KT4WkL...
Qed.

Theorem KT4WkRGen C : forall D L L', KT4Seq D L  L' -> KT4Seq D L (C++L').
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply KT4WkR...
Qed.

Theorem KT4WkLGen' C : forall D L L', KT4Seq D L  L' -> KT4Seq (C++D) L L'.
Proof with sauto.
  induction C;intros...
  rewrite <- app_comm_cons.
  apply KT4SeqWkL'...
Qed.

Lemma storeAll X : forall D L th, IsPositiveAtomFormulaL (Arrow2LL X) ->
  seq th L ((Arrow2LL X)++D) (UP []) -> seq th L D X.
Proof with sauto;SLSolve;OLSolve.
  destruct X;simpl;intros...
  * revert dependent L.
    revert D.
    revert dependent l.
    intro.
    induction l;intros...
    inversion H...
    inversion H3...
    store...
    apply IHl... LLExact H0.
    store...
    apply IHl... LLExact H0.
  * inversion H...
    inversion H3...
    all: release...
    all: store...
 Qed. 
   
Lemma storeAllN X : forall n D L th, IsPositiveAtomFormulaL (Arrow2LL X) ->
  seqN th n L ((Arrow2LL X)++D) (UP []) -> exists m, m <= S n +length (Arrow2LL X) /\ 
  seqN th m L D X.
Proof with sauto;SLSolve;OLSolve.
  destruct X;simpl;intros...
  * revert dependent L.
    revert D.
    revert dependent l.
    revert dependent n.
    intro.
    induction l;intros...
    exists n...
    inversion H...
    inversion H3...
    assert(exists m : nat,
        m <= S n + length l /\ seqN th m L (d| A |::D) (> l)).
    apply IHl... LLExact H0.
    destruct H2...
    eexists (S x)...
    store.
     assert(exists m : nat,
        m <= S n + length l /\ seqN th m L (u| A |::D) (> l)).
    apply IHl... LLExact H0.
    destruct H2...
    eexists (S x)...
    store.
  * inversion H...
    inversion H3...
    eexists (S (S n))...
    release...
    store...
    eexists (S (S n))...
    release...
    store...
 Qed.

Lemma storeAllInv X : forall D L th, IsPositiveAtomFormulaL (Arrow2LL X) ->
  seq th L D X -> seq th L ((Arrow2LL X)++D) (UP []).
Proof with sauto;SLSolve;OLSolve.
  destruct X;simpl;intros...
  * revert dependent L.
    revert D.
    revert dependent l.
    intro.
    induction l;intros...
    rewrite Permutation_cons_append.
    rewrite app_assoc_reverse.
    apply IHl...
    inversion H...
    inversion H0;inversion H3...
    LLExact H8.
    LLExact H8.
  * inversion H...
    inversion H0;inversion H3...
    all: inversion H7...
 Qed.  
  
Lemma adequacy_aux a j F L D X: 
mt a = true ->
mt j = true -> m4 j = true ->
IsPositiveAtomFormulaL X ->
IsPositiveAtomFormulaL D ->
IsPositiveAtomFormulaL (second L) ->
 isOLFormula (t_ucon BOX F) ->          
           seq (OLTheoryM (i:=j)) ((j, d|F |)::L) D (> X) <-> 
           seq (OLTheoryM (i:=j)) ((a,d| t_ucon BOX F|)::L) D (> X).
Proof with CleanContext;SLSolve;OLSolve. 
  intros aT jT jF isFX. split;intros.
 * 
   apply storeAll...
   apply storeAllInv in H2...
 decide3(makeRuleM BOX Left F j).
   apply ooth_modalM.
   constructor...
   tensorUnb (@nil oo) (X++D)...
   LLSwap.
   apply weakening...
 * 
   apply storeAll...
   apply storeAllInv in H2...
   apply seqtoSeqN in H2... 
   remember (X++D) as Y.
   assert(IsPositiveAtomFormulaL Y). 
   rewrite HeqY. OLSolve.
   clear HeqY.
   clear H isFX.
   rename H3 into H.
   revert dependent Y.
   revert dependent L.
   revert dependent F.
   revert dependent j.
   induction x using strongind;intros...
   - inversion H2...
   - inversion H2...
     -- apply RemoveNotPos1 in H6;sauto...
     -- contradict H7...
     -- apply InUNotPos in H4;sauto...
     -- apply RemoveNotPos2 in H8;sauto...
     -- inversion H5...
   + inversion H4...
     ++
        apply InvTensorNUnb in H7...
        apply FocusAtomNUnb in H11...
        +++
        decide3 (makeRuleConstant C Right).
        tensorUnb [u| t_cons C | ] x1.
        destruct C;simpl in *...
        solveLL.
        +++
        decide3 (makeRuleConstant C Right).
        tensorUnb (@nil oo) Y.
        apply InPermutation in H7...
        init2 x2 ((j, d| F |) ::x0).
        rewrite H7...
        destruct C;simpl in *...
        solveLL.
     ++
        apply InvTensorNUnb in H7...
        apply FocusAtomNUnb in H11...
        +++
        decide3 (makeRuleConstant C Left).
        tensorUnb [d| t_cons C | ] x1.
        destruct C;simpl in *...
        solveLL.
        +++
        decide3 (makeRuleConstant C Left).
        tensorUnb (@nil oo) Y.
        apply InPermutation in H7...
        init2 x2 ((j, d| F |) ::x0).
        rewrite H7...
        destruct C;simpl in *...
        solveLL.
   + inversion H4...
     ++
        apply InvTensorNUnb in H7...
        apply FocusAtomNUnb in H11...
        +++
        decide3 (makeRuleBinC C Right F1 G).
        tensorUnb [u| t_bin C F1 G | ] x1.
        destruct C;simpl in *...
        inversion H12...
        inversion H14...
        solveLL.
        inversion H16...
        apply H in H19...
        inversion H18...
        apply H in H19...
        inversion H12...
        inversion H13...
        inversion H16...
        oplus1.
        apply H in H18...
        inversion H13...
        inversion H16...
        oplus2.
        apply H in H18...
        inversion H12...
        inversion H14...
        inversion H15...
        inversion H18...
        solveLL.
        apply H in H19...
        rewrite H9 in H2...
        +++
        apply InPermutation in H7...
        rewrite H9.
        decide3 (makeRuleBinC C Right F1 G).
        tensorUnb (@nil oo) x1.
        init2 x2 ((j, d| F |)::x0).
        rewrite H7...
        destruct C;simpl in *...
        inversion H12...
        inversion H16...
        solveLL.
        inversion H18...
        apply H in H21...
        inversion H20...
        apply H in H21...
        inversion H12...
        inversion H15...
        inversion H18...
        oplus1.
        apply H in H20...
        inversion H15...
        inversion H18...
        oplus2.
        apply H in H20...
        inversion H12...
        inversion H16...
        inversion H17...
        inversion H20...
        solveLL.
        apply H in H21...
        rewrite H9 in H2...
     ++
        apply InvTensorNUnb in H7...
        apply FocusAtomNUnb in H11...
        +++
        decide3 (makeRuleBinC C Left F1 G).
        tensorUnb [d| t_bin C F1 G | ] x1.
        destruct C;simpl in *...
        inversion H12...
        inversion H13...
        inversion H16...
        oplus1.
        apply H in H18...
        inversion H13...
        inversion H16...
        oplus2.
        apply H in H18...
        
        inversion H12...
        inversion H14...
        solveLL.
        inversion H16...
        apply H in H19...
        inversion H18...
        apply H in H19...
        
        apply InvTensorNUnb in H12...
        inversion H11...
        inversion H16...
        tensorUnb x0 x2.
        apply H in H19...
        assert (IsPositiveAtomFormulaL x1).
        rewrite H9 in H2...
        OLSolve.
        inversion H12...
        inversion H18...
        apply H in H22...
        assert (IsPositiveAtomFormulaL x1).
        rewrite H9 in H2...
        OLSolve.
        +++
        apply InPermutation in H7...
        rewrite H9.
        decide3 (makeRuleBinC C Left F1 G).
        tensorUnb (@nil oo) x1.
        init2 x2 ((j, d| F |)::x0).
        rewrite H7...
        destruct C;simpl in *...
        inversion H12...
        inversion H15...
        inversion H18...
        oplus1.
        apply H in H20...
        inversion H15...
        inversion H18...
        oplus2.
        apply H in H20...
        
        inversion H12...
        inversion H16...
        solveLL.
        inversion H18...
        apply H in H21...
        inversion H20...
        apply H in H21...
        
        apply InvTensorNUnb in H12...
        inversion H12...
        inversion H18...
        tensorUnb x3 x4.
        apply H in H21...
        assert (IsPositiveAtomFormulaL x1).
        rewrite H9 in H2...
        OLSolve.
        inversion H13...
        inversion H20...
        apply H in H24...
        assert (IsPositiveAtomFormulaL x1).
        rewrite H9 in H2...
        OLSolve.
   + inversion H4...        
     ++
        apply InvTensorNUnb in H7...
        apply FocusAtomNUnb in H11...
        +++
        decide3 (makeRuleM C Right A j).
        tensorUnb [u| t_ucon C A | ] x1.
        destruct C;simpl in *...
        assert(x1=[]).
        inversion H12...
        subst.
        assert(j <> loc).
        intro...
        inversion H12...
        apply InvSubExpPhaseUK4 in H15...
        checkPermutationCases H9.
        {
        rewrite SetTPlusT in H17...
        inversion H17...
        rewrite H9 in H23.
        apply H in H23...
        solveLL.
        apply GenK4Rel' with (C4:=(j, d| F |)::x2) (CK:=[]) (CN:= x1)... 
        simpl...
        rewrite SetTPlusT... 
        rewrite plustpropT...
        solveLL.
        rewrite H9 in H11.
        inversion H11...
        symmetry in H16.
        srewrite H16 in H0... }
        {
        rewrite SetTPlusT in H17...
        inversion H17...
        solveLL.
        apply GenK4Rel' with (C4:=x0) (CK:=[]) (CN:=(j, d| F |)::x2)...
        rewrite <- H16... 
        rewrite SetTPlusT... 
        solveLL...
        HProof.  }
        +++
        apply InPermutation in H7...
        rewrite H9.
        decide3 (makeRuleM C Right A j).
        tensorUnb (@nil oo) x1.
        init2 x2 ((j, d| F |)::x0).
        rewrite H7...
        destruct C;simpl in *...
        assert(x1=[]).
        inversion H12...
        subst.
        assert (j <> loc).
        intro... 
        inversion H12...
        apply InvSubExpPhaseUK4 in H17...
        checkPermutationCases H9.
        {
        rewrite SetTPlusT in H19...
        inversion H19...
        rewrite H9 in H25.
        apply H in H25...
        solveLL.
        apply GenK4Rel' with (C4:=(j, d| F |)::x4) (CK:=[]) (CN:= x3)... 
        simpl...
        rewrite SetTPlusT... 
        rewrite plustpropT...
        solveLL.
        rewrite H9 in H13.
        inversion H13...
        symmetry in H18.
        srewrite H18 in H0... }
        {
        rewrite SetTPlusT in H19...
        inversion H19...
        solveLL.
        apply GenK4Rel' with (C4:=x1) (CK:=[]) (CN:=(j, d| F |)::x4)...
        rewrite <- H18... 
        rewrite SetTPlusT... 
        solveLL...
        HProof.  }
     ++
        apply InvTensorNUnb in H7...
        apply FocusAtomNUnb in H11...
        +++
        decide3 (makeRuleM C Left A j).
        tensorUnb [d| t_ucon C A | ] x1.
        destruct C;simpl in *...
        inversion H12...
        inversion H14...
        rewrite perm_swap in H15.
        apply H in H15...
        solveLL...
        LLExact H15.
        +++
        inversion H12...
        inversion H15...
        rewrite perm_swap in H16.
        apply H in H16...
        apply contraction with (F:=(j, d| A |))...
        LLExact H16.
        +++
        apply InPermutation in H7...
        decide3 (makeRuleM C Left A j).
        tensorUnb (@nil oo) Y.
        init2 x2 ((j, d| F |)::x0).
        rewrite H7...
        destruct C;simpl in *...
        inversion H12...
        inversion H16...
        rewrite perm_swap in H17.
        apply H in H17...
        solveLL...
        LLExact H17.
   +    apply InvTensorNUnb in H7...
        apply FocusAtomNUnb in H10...
      ++ 
        apply FocusAtomNUnb in H11...
        decide3 (RINIT OO).
        tensorUnb [u| OO |] [d| OO |].
        decide3 (makeRuleM BOX Right F j)...
        apply ooth_modalM.
        constructor...
        tensorUnb [u| t_ucon BOX F |] (@nil oo).
        intro...
        apply GenK4Rel' with (C4:=[(j, d| F |)]) (CK:=[]) (CN:=L)...
        simpl...
        rewrite plustpropT...
        solveLL.
        decide3 (RINIT F).
        apply ooth_initM...
        tensorUnb [u| F |] (@nil oo).
        apply InPermutation in H7...
        decide3 (RINIT OO).
        tensorUnb [u| OO |] (@nil oo).
        init2 x0 ((j, d| F |)::x1).
        rewrite H7...
      ++
        apply FocusAtomNUnb in H11...
        apply InPermutation in H7...
        decide3 (RINIT OO).
        tensorUnb (@nil oo) [d| OO |] .
        init2 x2 ((j, d| F |)::x0).
        rewrite H7...
        
        apply InPermutation in H7...
        decide3 (makeRuleM BOX Right F j)...
        apply ooth_modalM.
        constructor...
        tensorUnb. 
        init2 x2 ((j, d| F |) :: x1).
        rewrite H1...
        intro...
        apply GenK4Rel' with (C4:=[(j, d| F |)]) (CK:=[]) (CN:=L)...
        simpl...
        rewrite plustpropT...
        solveLL.
        decide3 (RINIT F).
        apply ooth_initM...
        tensorUnb [u| F |] (@nil oo).
        apply InPermutation in H7...
        apply InPermutation in H8...
        decide3 (RINIT OO).
        tensorUnb (@nil oo) (@nil oo).
        init2 x2 ((j, d| F |)::x1).
        rewrite H7...
        init2 x0 ((j, d| F |)::x3).
        rewrite H8...
   +    apply InvTensorNUnb in H7...
        apply FocusAtomNUnb in H10...
      ++ 
        inversion H11...
        inversion H14...
        rewrite perm_swap in H15. 
        apply H in H15...
        decide3(POS OO loc).
        tensorUnb [d| OO |] x1.
        LLExact H15...
      ++ 
         inversion H11...
         inversion H14...
         eapply H...
         rewrite Permutation_cons_append.
         apply ContractionLoc...
         LLExact H15.
      ++ 
        inversion H11...
        inversion H16...
        apply InPermutation in H7...
        decide3(POS OO loc).
        
        tensorUnb (@nil oo) Y.
        init2 x2 ((j, d| F |) :: x0).
        rewrite H7...
        rewrite perm_swap in H17. 
        apply H in H17...
        LLExact H17...
   +    apply InvTensorNUnb in H7...
        apply FocusAtomNUnb in H10...
      ++ 
        inversion H11...
        inversion H14...
        rewrite perm_swap in H15. 
        apply H in H15...
        decide3(NEG OO loc).
        tensorUnb [u| OO |] x1.
        LLExact H15...
      ++ 
        inversion H11...
        inversion H16...
        apply InPermutation in H7...
        decide3(NEG OO loc).
        
        tensorUnb (@nil oo) Y.
        init2 x2 ((j, d| F |) :: x0).
        rewrite H7...
        rewrite perm_swap in H17. 
        apply H in H17...
        LLExact H17...
  Qed.    
    
  
Lemma adequacy_aux_instance_loc j F L D X: 
mt j = true -> m4 j = true ->
IsPositiveAtomFormulaL X ->
IsPositiveAtomFormulaL D ->
IsPositiveAtomFormulaL (second L) ->
 isOLFormula (t_ucon BOX F) ->          
           seq (OLTheoryM (i:=j)) ((j, d|F |)::L) D (UP X) <-> 
           seq (OLTheoryM (i:=j)) ((loc,d| t_ucon BOX F|)::L) D (UP X).
Proof with CleanContext;SLSolve;OLSolve. 
  intros jT jF. split;intros.
  - apply adequacy_aux...
  - apply adequacy_aux in H3...
Qed.  
 


Lemma adequacy_auxK4_instance_loc j F L D : 
mt j = true -> m4 j = true ->
IsPositiveAtomFormulaL (second L) ->
IsPositiveAtomFormulaL (second D) ->
 isOLFormula F ->          
   tri_bangK4' (OLTheoryM (i:=j)) D j ((j, d|F |)::L) [] (UP []) <-> 
   tri_bangK4' (OLTheoryM (i:=j)) D j ((loc,d| t_ucon BOX F|)::L) [] (UP []).
Proof with CleanContext;SLSolve;OLSolve. 
   intros jT jF. split;intros.
 * apply InvSubExpPhaseUK4' in H2... 
   apply GenK4Rel' with (C4:= x) 
                        (CK:=[])
                        (CN:=x0)...
  apply adequacy_aux_instance_loc;auto. 
  rewrite secondApp.
  rewrite PlusT_fixpoint'. 
  OLSolve.
  srewrite H3 in H0.
  rewrite secondApp in H0...
  SLSolve.
 *  apply InvSubExpPhaseUK4' in H2... 
   
  apply GenK4Rel' with (C4:= x) 
                        (CK:=[])
                        (CN:=x0)...
  apply adequacy_aux_instance_loc;auto. 
  rewrite secondApp.
  rewrite PlusT_fixpoint'. 
  OLSolve.
  srewrite H3 in H0.
  rewrite secondApp in H0...
  SLSolve.
 Qed.

Lemma adequacy_auxK4 a j F L D : 
mt j = true -> m4 j = true ->
mt a = true -> m4 a = true ->
IsPositiveAtomFormulaL (second L) ->
IsPositiveAtomFormulaL (second D) ->
 isOLFormula F ->          
   tri_bangK4' (OLTheoryM (i:=j)) D j ((j, d|F |)::L) [] (UP []) <-> 
   tri_bangK4' (OLTheoryM (i:=j)) D j ((a,d| t_ucon BOX F|)::L) [] (UP []).
Proof with CleanContext;SLSolve;OLSolve. 
   intros aT aF jT jF. split;intros.
 * apply InvSubExpPhaseUK4' in H2... 
   apply GenK4Rel' with (C4:= x) 
                        (CK:=[])
                        (CN:=x0)...
  apply adequacy_aux;auto. 
  rewrite secondApp.
  rewrite PlusT_fixpoint'. 
  OLSolve.
  srewrite H3 in H0.
  rewrite secondApp in H0...
  SLSolve.
 *  apply InvSubExpPhaseUK4' in H2... 
   
  apply GenK4Rel' with (C4:= x) 
                        (CK:=[])
                        (CN:=x0)...
  apply adequacy_aux in H8;auto. 
  rewrite secondApp.
  rewrite PlusT_fixpoint'. 
  OLSolve.
  srewrite H3 in H0.
  rewrite secondApp in H0...
  SLSolve.
 Qed.

Lemma adequacy_auxK4' a j F L D Y X: 
mt j = true -> m4 j = true ->
mt a = true -> m4 a = true ->
lt j a ->
IsPositiveAtomFormulaL X ->
IsPositiveAtomFormulaL (second L) ->
IsPositiveAtomFormulaL (second D) ->
IsPositiveAtomFormulaL Y ->
 isOLFormula F ->          
   tri_bangK4' (OLTheoryM (i:=j)) ((j, d|F |)::D) j L Y (UP X) <-> 
   tri_bangK4' (OLTheoryM (i:=j)) ((a,d| t_ucon BOX F|)::D) j L Y (UP X).
Proof with CleanContext;SLSolve;OLSolve. 
   intros aT aF jT jF ltaj. split;intros.
 * apply InvSubExpPhaseUK4' in H4...
   checkPermutationCases H5.
   -  
   copyK4 a (d| t_ucon BOX F |) D...
   apply GenK4Rel' with (C4:= x1) 
                        (CK:=[])
                        (CN:=x0)...
  rewrite <- Permutation_cons_append.
  rewrite <- app_comm_cons.
  rewrite plustpropT...
  assert(SetT x).
  SLSolve.
  assert(SetT x1).
  SLSolve.  
  rewrite PlusT_fixpoint'...
  apply adequacy_aux;auto. 
  rewrite secondApp.
  symmetry in H9.
  srewrite H9 in H1.
  rewrite secondApp in H1...
  srewrite H5 in H10.
  LLExact H10.
  - 
   rewrite Permutation_cons_append. apply weakeness_mutual'...
   apply GenK4Rel' with (C4:= x) 
                        (CK:=[])
                        (CN:=x1)...
 * apply InvSubExpPhaseUK4' in H4...
   checkPermutationCases H5.
   -  
   copyK4 j (d| F |) D...
   apply GenK4Rel' with (C4:= x1) 
                        (CK:=[])
                        (CN:=x0)...
  rewrite <- Permutation_cons_append.
  rewrite <- app_comm_cons.
  rewrite plustpropT...
  assert(SetT x).
  SLSolve.
  assert(SetT x1).
  SLSolve.  
  rewrite PlusT_fixpoint'...
  rewrite H5 in H10.
  rewrite <- Permutation_middle in H10.
  apply adequacy_aux in H10;auto. 
  rewrite secondApp.
  symmetry in H9.
  srewrite H9 in H1.
  rewrite secondApp in H1...
  - 
   rewrite Permutation_cons_append. apply weakeness_mutual'...
   apply GenK4Rel' with (C4:= x) 
                        (CK:=[])
                        (CN:=x1)...
  Qed.                      
 
 
 Theorem  SoundenessKT4T j A B D R L
     (Mj: mt j = true) (Fj: m4 j = true)
     (isFL: isOLFormulaL L) (isFR: isOLFormulaL R)
     (isFD: isOLFormulaL D) (isFA: isOLFormulaL A) : 
     forall  (Hyp: KT4SeqT A B D L R), 
     tri_bangK4' (OLTheoryM (i:=j)) (CEncode j (LEncode A)) j
     (CEncode j (LEncode D) ++ (CEncode loc (LEncode L) ++ CEncode loc (REncode R))) [] (> []) with 
      SoundenessKT4 j D L R
     (Mj: mt j = true) (Fj: m4 j = true)
     (isFD: isOLFormulaL D) (isFL: isOLFormulaL L) (isFR: isOLFormulaL R)  : 
     forall (Hyp: KT4Seq D L R), 
     seq (OLTheoryM (i:=j)) 
     (CEncode j (LEncode D) ++ (CEncode loc (LEncode L) ++ CEncode loc (REncode R))) [] (> []).
Proof with CleanContext;SLSolve;OLSolve.
  * clear SoundenessKT4T.
  intros.
  induction Hyp.
  + apply Remove_Permute in H...
    rewrite H in isFA.
    srewrite H...
    apply IHHyp in isFD...
    clear IHHyp.
    copyK4 j (d| F |) (CEncode j (LEncode A')).
    rewrite plustpropT...
    apply ContractionLocK4'...
    eapply exchangeCCKK4.
    2:{ exact isFD. } 
    perm.
  + apply Remove_Permute in H...
    rewrite H in isFA.
    srewrite H...
    apply IHHyp in isFR...
    clear IHHyp.
    copyK4 j (d| F |) (CEncode j (LEncode A')).
    rewrite plustpropT...
    eapply exchangeCCKK4.
    2:{ exact isFR. } 
    perm.
  + eapply SoundenessKT4 with (j:=j)  in H...
    finishExp...
  * clear SoundenessKT4. 
    intros.
    induction Hyp.
     + (* True on the right *)
    decide3 (makeRuleConstant TT Right)...
    constructor;constructor;auto.
    tensorUnb...
    rewrite  Permutation_cons_append...
    rewrite !app_assoc...
    solveLL... 
   + (* false on the left *)
    decide3 (makeRuleConstant FF Left)...
    constructor;constructor;auto.
    tensorUnb...
   +
    decide3 (RINIT F)...
    apply ooth_initM...
    tensorUnb...
    rewrite  Permutation_cons_append...
    apply weakeningGen...
    rewrite  Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen_rev...
    solveLL...
   +
    decide3 (makeRuleBinC AND Left F G)...
    apply ooth_rulesM...
    constructor...
    tensorUnb...
    oplus1.
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen_rev...
    apply PosF with (a:=loc)...
    apply IHHyp in isFR as Hs...
    LLExact Hs.
   + 
    decide3 (makeRuleBinC AND Left F G)...
    apply ooth_rulesM...
    constructor...
    tensorUnb...
    oplus2.
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen_rev...
    apply PosF with (a:=loc)...
    apply IHHyp in isFR as Hs...
    LLExact Hs.
    +
    decide3 (makeRuleBinC AND Right F G)...
    apply ooth_rulesM...
    constructor...
    tensorUnb...
    apply weakeningGen... 
    solveLL. SLSolve.
    
    1-2: rewrite Permutation_cons_append...
    1-2: rewrite !app_assoc.
    1-2: apply weakeningGen_rev...
   
    1-2: apply NegF with (a:=loc)...
   
    apply IHHyp1 in isFL...
    LLExact isFL.
    apply IHHyp2 in isFL...
    LLExact isFL.
   + 
    decide3 (makeRuleBinC OR Left F G)...
    apply ooth_rulesM...
    constructor...
    tensorUnb...
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen_rev...
    apply PosF with (a:=loc)...
    apply IHHyp1 in isFR as Hs...
    LLExact Hs.
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen_rev...
    apply PosF with (a:=loc)...
    apply IHHyp2 in isFR as Hs...
    LLExact Hs.
   + 
    decide3 (makeRuleBinC OR Right F G)...
    apply ooth_rulesM...
    constructor...
    tensorUnb...
    apply weakeningGen... 
    solveLL. SLSolve.
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen_rev...
    oplus1.
    apply NegF with (a:=loc)...
   
    apply IHHyp in isFL...
    LLExact isFL.
    +
    decide3 (makeRuleBinC OR Right F G)...
    apply ooth_rulesM...
    constructor...
    tensorUnb...
    apply weakeningGen... 
    solveLL. SLSolve.
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen_rev...
    oplus2.
    apply NegF with (a:=loc)...
   
    apply IHHyp in isFL...
    LLExact isFL.
    + 
    decide3 (makeRuleBinC IMP Left A B)...
    apply ooth_rulesM...
    constructor...
    tensorUnb...
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen_rev...
    tensorUnb...
    rewrite REncodeApp.
    setoid_rewrite LEncodeApp.
    rewrite !CEncodeApp.
    repeat rewrite app_assoc.
    apply weakeningGen_rev...
    rewrite app_assoc_reverse.
    repeat rewrite app_assoc_reverse.
    rewrite Permutation_midle_app.
    rewrite <- Permutation_app_rot.
    repeat rewrite app_assoc_reverse.
 
    apply weakeningGen...
    
    apply NegF with (a:=loc)...
    assert(isOLFormulaL (A :: L1'))...
    apply IHHyp1 in H...
    LLExact H. inversion isFL...
    
    rewrite REncodeApp.
    setoid_rewrite LEncodeApp.
    rewrite !CEncodeApp.
    repeat rewrite app_assoc_reverse.
    rewrite Permutation_midle_app.
    apply weakeningGen... 
    rewrite <- Permutation_app_rot.
    repeat rewrite app_assoc_reverse.
    apply weakeningGen...
    apply PosF with (a:=loc)...
    assert(isOLFormulaL (B :: L2)).
    inversion isFL...
    apply IHHyp2 in H...
    LLExact H.
    + decide3 (makeRuleBinC IMP Right A B)...
    apply ooth_rulesM...
    constructor...
    tensorUnb...
    apply weakeningGen... 
    solveLL. SLSolve.
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply weakeningGen_rev...
    apply NegF with (a:=loc)...
    apply PosF with (a:=loc)...
    assert(isOLFormulaL (B :: L')).
    OLSolve.
    apply IHHyp in H...
    LLExact H.
   + (* exchange *)
    srewrite (symmetry H)...
    apply IHHyp...
   + (* exchange *)
    srewrite (symmetry H)...
    apply IHHyp...    
  + (* contraction *)
    eapply @contraction with (F:=(loc, d| F |))...
    apply IHHyp in isFR... 
    LLExact isFR.
    OLSolve.
  + (* contraction *)
    eapply @contraction with (F:=(loc, u| F |))...
    apply IHHyp in isFL... 
    LLExact isFL.
    OLSolve.
    apply in_or_app.
    right...
  + (* weakening *)
    simpl. rewrite Permutation_midle.
    apply weakening...
    apply IHHyp...
   + (* weakening *)
    simpl. rewrite Permutation_cons_append.
    rewrite !app_assoc.
    apply weakeningGen_rev...
    rewrite !app_assoc_reverse.
    apply IHHyp...
  + (* decide T *)
    apply InPermutation in H... 
    srewrite H...
    rewrite Permutation_cons_append...
    rewrite !app_assoc.
    apply ContractionL'...
    rewrite H in isFD.
    assert(isOLFormulaL (F :: L))...
    apply IHHyp in H0...
    eapply exchangeCC'.
    2:{ exact H0. }
    srewrite H... 
  + (* box left *)
    assert(isOLFormulaL (F :: D))...
    apply IHHyp in H...
    rewrite <- Permutation_middle.
    apply adequacy_aux_instance_loc;auto. 
    rewrite !secondApp.
    rewrite !secCEncode...
    OLSolve. inversion isFL... OLSolve.
    OLSolve. OLSolve.
  + (* box right *)
    decide3(makeRuleM BOX Right F j).
    apply ooth_modalM.
    constructor...
    tensorUnb...
    rewrite Permutation_cons_append.
    apply weakeningGen...
    apply weakeningGen...
    solveLL. SLSolve.
    
    apply SoundenessKT4T with (j:=j) in H...
    apply InvSubExpPhaseUK4' in H... 
   
    rewrite Permutation_cons_append.
    rewrite !app_assoc.
   apply weakeness_mutual'...
   apply destructCEncode in H0...
   apply destructLEncode in H7...
   rewrite PlusT_fixpoint' in H5...
   
   apply LEncodePerm in H9.
   setoid_rewrite LEncodeApp in H9.
   apply CEncodePerm with (i:=j) in H9.
   rewrite H9.
   rewrite CEncodeApp.
   rewrite !app_assoc_reverse.
   apply weakeness_mutualGen'...
   eapply @GenK4Rel' with (C4:=x) (CK:=[]) (CN:=[])...
   apply CEncodePerm with (i:=j) in H4.
   rewrite H0...
   rewrite PlusT_fixpoint'...
   solveLL.
   apply NegF with (a:=loc)...
 Qed.

Tactic Notation "decideT" := 
       match goal with
        | [ |- ?P :: ?X; ?L |-- ?R] =>  eapply @KT4Dec with (F:= P);sauto
       end.
       
Tactic Notation "decideTW" := 
       match goal with
        | [ |- ?P :: ?X; ?L |-- ?R] =>  eapply @KT4Dec with (F:= P);sauto; try apply KT4SeqTWkL1
       end.


(** Completeness theorem *)  
Theorem Completeness: forall n j D L1 L2 R1 R2, 
    m4 j = true -> mt j = true ->
    isOLFormulaL D ->
    isOLFormulaL L1 ->
    isOLFormulaL L2 ->
    isOLFormulaL R1 ->
    isOLFormulaL R2 ->
    seqN (OLTheoryM (i:=j)) n 
    (CEncode j (LEncode D) ++ (CEncode loc (LEncode L1) ++ CEncode loc (REncode R1))) (LEncode L2 ++  REncode R2) 
    (> []) ->
    KT4Seq D (L1++L2) (R1++R2).
Proof with CleanContext;SLSolve;OLSolve.
  intro.
  induction n using strongind; intros j D L1 L2 R1 R2 Fj Mj HisD HisL1 HisL2 HisR1 HisR2 Hseq; 
  inversion Hseq...
  * apply RemoveNotPos1 in H2;sauto...
    OLSolve. OLSolve.
  * apply InUNotPos in H4;sauto.
    rewrite !secondApp.
    rewrite !secCEncode.
    OLSolve. all: OLSolve.
  * apply RemoveNotPos2 in H4;sauto.
    rewrite !secondApp.
    rewrite !secCEncode.
    OLSolve. all:OLSolve.
  * inversion H1...
  + inversion H0...
  ++ (* Constant right *)
      apply FocusingRightCteU in H3...
      -
      apply checkEncodeCasesU in H7... 
      (* by cases on C *)
      destruct C...
      apply OLInPermutation' in H5...
      rewrite H5...
      rewrite <- perm_takeit_2...
      inversion H8...
      - destruct C.
        rewrite !secCEncode in H7.
        rewrite app_assoc in H7.
        rewrite <- LEncodeApp in H7.
        apply upRight in H7.
        apply OLInPermutation in H7...
        rewrite H3...
        inversion H8...
    ++ (* constant left *)
      apply FocusingLeftCteU in H3...
      -
      apply checkEncodeCasesD in H7... 
      destruct C...
      inversion H8...
      apply OLInPermutationL' in H5...
      rewrite H5...
      rewrite <- perm_takeit_2...
      - destruct C.
       inversion H8...
       rewrite !secCEncode in H7.
       rewrite app_assoc in H7.
       rewrite <- LEncodeApp in H7.
       apply downLeft in H7.
       apply OLInPermutationL in H7...
       checkPermutationCases H3.
       rewrite H5.
       decideTW.
       rewrite H5...
  + inversion H0... 
    ++ (* binary connective right *)
      apply FocusingRightCRuleU in H3...
      -
      apply checkEncodeCasesU in H7...
       (* by cases on C *)
      destruct C...
      { apply AppPARTENSORRightC in H8...
        apply OLInPermutation' in H5...
        rewrite H5 in HisR2.
        rewrite H5...
        rewrite <- perm_takeit_2...
        apply KT4AndR...
        
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x2)...
        LLExact H9.
        rewrite <- H6...
        
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x2)...
        LLExact H10.
        rewrite <- H6...
      }  
      { (*  OR *)
        apply AppTENSORPARRightC in H8...
        apply OLInPermutation' in H5...
        rewrite H5 in HisR2.
        rewrite H5...
        rewrite <- perm_takeit_2...  
        apply KT4OrR1...
        
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x2)...
        LLExact H8.
        rewrite <- H6...
        
        apply OLInPermutation' in H5...
        rewrite H5 in HisR2.
        rewrite H5...
        rewrite <- perm_takeit_2...  
        apply KT4OrR2...
        
        rewrite perm_takeit_2...
        eapply H with (j:=j) (m:=x2)...
        LLExact H8.
        rewrite <- H6...
      }
      { (* impl *)
         apply AppTENSORPAREXCHRightC in H8...
        apply OLInPermutation' in H5...
        rewrite H5 in HisR2.
        rewrite H5...
        rewrite <- perm_takeit_2...  
        apply KT4ImpR...
        
        rewrite !perm_takeit_2...
        eapply H with (m:=x2) (j:=j)...
        LLExact H8.
        rewrite <- H6... }
      - destruct C...
      { apply AppPARTENSORRightC in H8...
        rewrite !secCEncode in H7.
        rewrite app_assoc in H7.
        rewrite <- LEncodeApp in H7.
        apply upRight in H7.
        apply OLInPermutation in H7...
        rewrite H3...
        apply KT4CtR.
        apply KT4AndR.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (m:=x0) (j:=j)...
        LLExact H8.
        
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (m:=x0) (j:=j)...
        LLExact H9. 
      }
      { rewrite !secCEncode in H7.
        rewrite app_assoc in H7.
        rewrite <- LEncodeApp in H7.
        apply upRight in H7.
        apply OLInPermutation in H7...
        
        apply AppTENSORPARRightC in H8...
        
        rewrite H3...
        apply KT4CtR.
        apply KT4OrR1.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (m:=x1) (j:=j)...
        LLExact H7.
        
        rewrite H3...
        apply KT4CtR.
        apply KT4OrR2.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        eapply H with (m:=x1) (j:=j)...
        LLExact H7.
     }
     {  rewrite !secCEncode in H7.
        rewrite app_assoc in H7.
        rewrite <- LEncodeApp in H7.
        apply upRight in H7.
        apply OLInPermutation in H7...
       
        apply AppTENSORPAREXCHRightC in H8...
        rewrite H3...
        apply KT4CtR.
        apply KT4ImpR.
        rewrite app_comm_cons.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite perm_takeit_2...
        rewrite perm_takeit_2. 
        eapply H with (m:=x1) (j:=j)...
        LLExact H7.
       }
    ++ (* binary connective left *)
      apply FocusingLeftCRuleU in H3...
      -
      apply checkEncodeCasesD in H7...
       (* by cases on C *)
      destruct C...
      { apply AppPARTENSORLeftC in H8...
        apply OLInPermutationL' in H5...
        rewrite H5 in HisL2.
        rewrite H5...
        rewrite <- perm_takeit_2...
        apply KT4AndL1...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (j:=j)...
        LLExact H8.
        
        apply OLInPermutationL' in H5...
        rewrite H5 in HisL2.
        rewrite H5...
        rewrite <- perm_takeit_2...
        apply KT4AndL2...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (j:=j)...
        LLExact H8.
      }  
      { (*  OR *)
        apply OLInPermutationL' in H5...
        rewrite H5 in HisL2.
        rewrite H5...
        rewrite <- perm_takeit_2...
        
        apply AppTENSORPARLeftC in H8... 
          
        apply KT4OrL...
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (j:=j)...
        LLExact H9.
        
        rewrite perm_takeit_2...
        eapply H with (m:=x2) (j:=j)...
        LLExact H10.
      }
      { (* impl *)
        apply OLInPermutationL' in H5...
        rewrite H5 in HisL2.
        apply KT4CtLGen.
        apply KT4CtRGen.
        rewrite H5...
        rewrite <- perm_takeit_2...
        rewrite <- perm_takeit_2...
          
        apply AppTENSORPAREXCHLeftC in H8...   
        rewrite H9 in H6.
        apply destructEncode in H6...
        rewrite H13.
        rewrite H7.
        assert(Hs1:Permutation (t_bin IMP F0 G :: L1 ++ L1 ++ x ++ x6) 
              (t_bin IMP F0 G :: (L1 ++ x) ++ (L1++x6))) by perm.
              
        assert(Hs2:Permutation (R1 ++ R1 ++ x5 ++ x7) ((R1 ++ x5) ++ (R1++x7))) by perm.
        
        rewrite Hs1. rewrite Hs2.
        apply KT4ImpL...
        rewrite Permutation_cons_append.
        rewrite app_assoc_reverse.
        eapply H with (m:=x2) (j:=j)...
        assert(isOLFormulaL x1)...
        OLSolve.
        LLExact H8.
        rewrite REncodeApp.
        rewrite H6...
        rewrite Permutation_cons_append.
        rewrite app_assoc_reverse.
        eapply H with (m:=x2) (j:=j)...
        assert(isOLFormulaL x1)...
        LLExact H11.
        rewrite LEncodeApp.
        rewrite H10...
      }
      - destruct C...
      { rewrite !secCEncode in H7.
        rewrite app_assoc in H7.
        rewrite <- LEncodeApp in H7.
        apply downLeft in H7.
        apply OLInPermutationL in H7...
        checkPermutationCases H3.
        rewrite H5.
        apply AppPARTENSORLeftC in H8...
        decideT.
        apply KT4AndL1.
        rewrite <- Permutation_midle.
        eapply H with (m:=x2) (j:=j)...
        
        LLExact H8.
        srewrite H5...
        
        decideT.
        apply KT4AndL2.
        rewrite <- Permutation_midle.
        eapply H with (m:=x2) (j:=j)...
        
        LLExact H8.
        srewrite H5...
        
        rewrite H5.
        apply AppPARTENSORLeftC in H8...
        apply KT4CtL.
        apply KT4AndL1.
        rewrite app_comm_cons.
        rewrite <- H5.
        rewrite <- Permutation_midle.
        eapply H with (m:=x2) (j:=j)...
        apply KT4CtL.
        apply KT4AndL2.
        rewrite app_comm_cons.
        rewrite <- H5.
        rewrite <- Permutation_midle.
        eapply H with (m:=x2) (j:=j)... }
      { rewrite !secCEncode in H7.
        rewrite app_assoc in H7.
        rewrite <- LEncodeApp in H7.
        apply downLeft in H7.
        apply OLInPermutationL in H7...
        checkPermutationCases H3.
        rewrite H5.
        apply AppTENSORPARLeftC in H8...
        decideT.
        apply KT4OrL.
        rewrite <- H5.
        rewrite <- Permutation_midle.
        eapply H with (m:=x2) (j:=j)...
        rewrite <- H5.
        rewrite <- Permutation_midle.
        eapply H with (m:=x2) (j:=j)...
        rewrite H5.
        apply AppTENSORPARLeftC in H8...
        apply KT4CtL.
        apply KT4OrL.
        rewrite app_comm_cons.
        rewrite <- H5.
        rewrite <- Permutation_midle.
        eapply H with (m:=x2) (j:=j)...
        rewrite app_comm_cons.
        rewrite <- H5.
        rewrite <- Permutation_midle.
        eapply H with (m:=x2) (j:=j)... }
     { rewrite !secCEncode in H7.
        rewrite app_assoc in H7.
        rewrite <- LEncodeApp in H7.
        apply downLeft in H7.
        apply OLInPermutationL in H7...
        checkPermutationCases H3.
        rewrite H5...
        apply AppTENSORPAREXCHLeftC in H8...
        apply destructEncode in H9...
        apply KT4CtRGen.
        apply KT4CtLGen.
        rewrite H9.
        rewrite H13.
        eapply KT4ExL with (L:=(L1++x)++(L1++x6))...
        eapply KT4ExR with (L:=(R1++x5)++(R1++x7))...
        decideT.
        apply KT4ImpL.
        1-2: rewrite <- H5.
        rewrite <- Permutation_midle.
        eapply H with (m:=x2) (j:=j)...
        LLExact H8.
        rewrite H7...
        rewrite <- Permutation_midle.
        eapply H with (m:=x2) (j:=j)...
        LLExact H11.
        apply AppTENSORPAREXCHLeftC in H8...
        apply destructEncode in H9...
        rewrite H5...
        apply KT4CtL.
        rewrite app_comm_cons.
        rewrite <- H5...
        rewrite <- Permutation_midle.
        apply KT4CtRGen.
        apply KT4CtLGen.
        do 2 rewrite Permutation_midle.
        rewrite H9.
        rewrite H13.
        assert(Permutation (L1 ++ L1 ++ x ++ x6) ((L1++x)++(L1++x6))) by perm.
        rewrite H3.
        eapply KT4ExR with (L:=(R1++x5)++(R1++x7))...
        apply KT4ImpL.
        rewrite <- Permutation_midle.
        eapply H with (m:=x2) (j:=j)...
        LLExact H8.
        rewrite H7...
        rewrite <- Permutation_midle.
        eapply H with (m:=x2) (j:=j)...
        LLExact H11.
       }     
    + inversion H0... 
    ++ apply FocusingRightMU in H3;sauto.
       { 
        apply checkEncodeCasesU in H7...
        apply OLInPermutation' in H5...
        destruct C...
        apply AppQUESTBANGRight in H8...
        apply map_eq_nil in H3...
        apply map_eq_nil in H6...
        rewrite Permutation_app_comm...
        apply KT4BoxR.
         apply destructClassicSetK4 with (a:=j) in H8...
        2:  apply setK4CEncodeM4...
        assert(x5 = []).
        rewrite <- CEncodeApp in H6.
        apply SetK4_Loc with (i:=j) in H6...
        subst. 
        apply destructCEncode in H5...
        apply destructLEncode in H15...
       
        eapply ImpGen with (A1:=x8) (A2:=[]) (A3:=x9)...
        change [A] with ([]++[A]).
        rewrite <- (app_nil_l [ ]).
        eapply H with (m:=x2) (j:=j)...
        LLExact H13.
        rewrite H8.
        rewrite H5.
        srewrite H10... }
    { rewrite !secondApp in H7. 
      rewrite !secCEncode in H7...
      rewrite app_assoc in H7.
      rewrite <- LEncodeApp in H7.
      apply upRight in H7...
      apply OLInPermutation in H7...
      destruct C...
        apply AppQUESTBANGRight in H8...
        apply map_eq_nil in H5...
        apply map_eq_nil in H9...
        rewrite H3.
        apply KT4BoxR.
      apply destructClassicSetK4 with (a:=j) in H7...
        2:  apply setK4CEncodeM4...
        assert(x6 = []).
        rewrite <- CEncodeApp in H9.
        apply SetK4_Loc with (i:=j) in H9...
        subst. 
        apply destructCEncode in H7...
        apply destructLEncode in H16...
       
        eapply ImpGen with (A1:=x9) (A2:=[]) (A3:=x10)...
        change [A] with ([]++[A]).
        rewrite <- (app_nil_l [ ]).
        eapply H with (m:=x1) (j:=j)...
        LLExact H12.
        rewrite H11.
        rewrite H7.
        srewrite H13... }   
   ++ apply FocusingLeftMU in H3;sauto.
       { 
        apply checkEncodeCasesD in H7...
       apply OLInPermutationL' in H5...
        destruct C...
       simpl in H8.
       inversion H8...
       inversion H12...
       clear H8 H12.
       rewrite H5.
       rewrite <- Permutation_middle.
       apply KT4BoxL.
       eapply H with (m:=n0) (j:=j)...
        rewrite  H6... }
      { rewrite !secondApp in H7. 
      rewrite !secCEncode in H7...
      rewrite app_assoc in H7.
      rewrite <- LEncodeApp in H7.
      apply downLeft in H7...
      apply OLInPermutationL in H7...
        destruct C...
       simpl in H8.
       inversion H8...
       inversion H11...
       clear H8 H11.
      checkPermutationCases H3.
       rewrite H5.
       decideT.
      apply KT4BoxL.
      rewrite <- H5.
      eapply H with (m:=n0) (j:=j)...
      
      rewrite H5.
      rewrite <- app_comm_cons.
      apply KT4CtL.
      apply KT4BoxL.
      rewrite app_comm_cons. 
      rewrite <- H5.
      eapply H with (m:=n0) (j:=j)... }
  + apply FocusingInitRuleU in H3;sauto.
    ++   
      apply destructEncode in H4...
      all: try repeat match goal with
      | [H: REncode _ = nil |- _] => apply map_eq_nil in H;sauto
      | [H: LEncode _ = nil |- _] => apply map_eq_nil in H;sauto
      | [H: REncode _ = [_] |- _] => apply map_eq_cons in H;sauto
      | [H: LEncode _ = [_] |- _] => apply map_eq_cons in H;sauto
      end... 
      rewrite Permutation_app_comm...
      rewrite Permutation_app_comm...
    ++  CleanContext.
        rewrite !setUtoGetU in H6...
        rewrite !secCEncode in H6...
        rewrite app_assoc in H6.
        rewrite <- LEncodeApp in H6.
        apply downLeft in H6.
        apply OLInPermutationL in H6...
        checkPermutationCases H3.
        all: try repeat match goal with
      | [H: REncode _ = nil |- _] => apply map_eq_nil in H;sauto
      | [H: LEncode _ = nil |- _] => apply map_eq_nil in H;sauto
      | [H: REncode _ = [_] |- _] => apply map_eq_cons in H;sauto
      | [H: LEncode _ = [_] |- _] => apply map_eq_cons in H;sauto
      end...
      rewrite H4.
      decideT.
      rewrite <- Permutation_middle...
      rewrite H4.
      rewrite <- Permutation_middle...
    ++ apply map_eq_cons in H5... 
    ++ apply map_eq_cons in H7...
    ++  CleanContext. 
        rewrite !setUtoGetU in H6...
        rewrite !secCEncode in H6...
        rewrite app_assoc in H6.
        rewrite <- LEncodeApp in H6.
        apply upRight in H6.
        apply map_eq_cons in H4...
        
        apply OLInPermutation in H6...
        rewrite H3...
        rewrite <- Permutation_middle...
    ++  CleanContext. 
        rewrite !setUtoGetU in H5...
        rewrite !secCEncode in H5...
        rewrite app_assoc in H5.
        rewrite <- LEncodeApp in H5.
        
        apply downLeft in H5.
         apply OLInPermutationL in H5...
        
        rewrite !setUtoGetU in H4...
        rewrite !secCEncode in H4...
        rewrite app_assoc in H4.
        rewrite <- LEncodeApp in H4.
        
        apply upRight in H4.
        apply OLInPermutation in H4...
        
        rewrite H4.
        apply map_eq_nil in H3...
        apply map_eq_nil in H6...
        checkPermutationCases H5.
        rewrite H5.
        decideT...
        rewrite H5...
    +
       apply FocusingPOSU in H3...
    ++  apply checkEncodeCasesD in H6... 
        apply OLInPermutationL' in H4...
        rewrite H4.
        rewrite <- Permutation_middle.
        rewrite app_comm_cons.
        eapply H with (m:=x) (j:=j)...
        LLExact H7.
    ++  CleanContext.
        rewrite !secCEncode in H6.
        rewrite app_assoc in H6.
        rewrite <- LEncodeApp in H6.
        apply downLeft in H6.
        apply OLInPermutationL in H6...
        checkPermutationCases H3.
        rewrite H4.
        decideT.
        rewrite app_comm_cons.
        eapply H with (m:=x) (j:=j)...
        LLExact H7.
        srewrite H4...
        rewrite H4.
        rewrite <- app_comm_cons.
        apply KT4CtL.
        rewrite app_comm_cons.
        rewrite <- H4.
        rewrite app_comm_cons.
        eapply H with (m:=x) (j:=j)...
        LLExact H7.
    + apply FocusingNEGU in H3...
   
    ++  apply checkEncodeCasesU in H6... 
        apply OLInPermutation' in H4...
        rewrite H4.
         rewrite <- perm_takeit_2...
       rewrite app_comm_cons.
        eapply H with  (j:=j) (m:=x)...
        LLExact H7.
    ++  rewrite !secCEncode in H6.
        rewrite app_assoc in H6.
        rewrite <- LEncodeApp in H6.
        apply upRight in H6.
        apply OLInPermutation in H6...
        rewrite H3.
        rewrite <- app_comm_cons.
        apply KT4CtR.
        rewrite app_comm_cons.
        rewrite <- H3.
        rewrite app_comm_cons.
        eapply H with (j:=j) (m:=x)...
        LLExact H7.  
Qed.

Lemma  SoundenessKT4' j D L1 R1 L2 R2 :
     mt j = true -> m4 j = true ->
      isOLFormulaL D ->
      isOLFormulaL L1 ->
      isOLFormulaL R1 ->
      isOLFormulaL L2 ->
      isOLFormulaL R2 ->
      KT4Seq D (L1++L2) (R1++R2) ->
      seq (OLTheoryM (i:=j)) 
     (CEncode j (LEncode D) ++ (CEncode loc (LEncode L1) ++ CEncode loc (REncode R1))) (LEncode L2 ++ REncode R2) (> []).
 Proof with OLSolve.
 
 intros Mt Ft isFD isFL1 isFR1 isFL2 isFR2 Hyp.
  eapply PosNegSetT with (a:=loc) (b:=loc)...
  eapply SoundenessKT4 with (j:=j) in Hyp...
  eapply exchangeCC'.
  2:{ exact Hyp. }
  rewrite LEncodeApp.
  rewrite REncodeApp.
  rewrite !CEncodeApp... perm.
  Qed.     
     

 Theorem AdequacyKT4 j D L1 R1 L2 R2: 
   mt j = true -> m4 j = true ->
      isOLFormulaL D ->
      isOLFormulaL L1 ->
      isOLFormulaL R1 ->
      isOLFormulaL L2 ->
      isOLFormulaL R2 ->
   KT4Seq D (L1 ++ L2) (R1 ++ R2) <->
   seq (OLTheoryM (i:=j)) 
     (CEncode j (LEncode D) ++ (CEncode loc (LEncode L1) ++ CEncode loc (REncode R1))) (LEncode L2 ++ REncode R2) (> []).  
Proof with sauto. 
 intros.
  split;intros.
  + apply SoundenessKT4'... 
  + apply seqtoSeqN in H6... 
    apply Completeness in H6...
Qed.

End KT4Adequacy. 

